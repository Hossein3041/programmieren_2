Programmierung II - Java Swing und ein wenig Threads (Nebenläufigkeit)

Ziel der Vorlesung:
- Programmierung graphischer Oberflächen in Java mit Swing
- Threads
- einfache Netzwerkprogrammierung

Parallel in Algorithmen:
- Sortierverfahren
- dynamische Datenstrukturen (Vektoren und Listen)
-   Suchverfahren (Bäume und Hashing)
________________________________________________________________________________________________________________________
                Vorlesung 1 - Graphikprogrammierung: Motivation
Aufgabe: Text ausgeben auf der Konsole
    System.out.println("Das war einfach.");
Aufgabe: Text ausgeben in einem eigenen Fenster
-   Wie wird ein Fenster erzeugt?
-   Wie wird der Text ausgegeben?
-   Wo wird der Text ausgegeben?
-   Welche Farbe hat er, welcher Font wird verwendet?
-   Was passiert, wenn das Fenster geschlossen und wieder geöffnet wird?

Aufgabe: einen roten Kreis in einem eigenen Fenster zeichnen
- wieder: Wie wird ein Fenster erzeugt?
- wieder: Was passiert, wenn das Fenster geschlossen und wieder geöffnet wird?
- Gibt es einen Befehl für Kreise, oder mus jeder Punkt berechnet werden?
- Wie wird die Farbe gesetzt?

Lösungsansätze in Java
Verschiedene Frameworks für Grafikprogrammierung
- Abstract Windowing Toolkit (AWT)
- Swing
- SWT
- Java FX

Beispiel 1

Fähigkeiten von Swing:
- graphische Primitivoperationen zum Zeichnen und Ausgeben von Text
- Steuerung des Programmablaufs mittels Maus-, Tasten- und Fensterevents
- einfache und komplexe Dialogelemente
- komplexere graphische Operationen für Bitmaps und Sound

import javax.swing.*;
class VL_01_Beispiel1 {
    public static void main(String[] args){
        JFrame frame = new JFrame("Mein erstes Fenster");
        frame.setSize(400,300);
        frame.setVisible(true);
    }
}

Erläuterung:
1. Importieren des Graphikpakets: import javax.swings.*;
2. Anlegen eines Frames:          new JFrame("Mein erstes Fenster");
3. Setzen der Größe:              frame.setSize(400,300);
4. Sichtbar machen:               frame.setVisible(true);

Swing: Schließen von Fenstern
- Das Verhalten des Schließen-Buttons kann eingestellt werden
- Mittels des Befehls setDefaultCloseOperation kann zwischen den folgenden vier Verhalten unterschieden werden
    DO_NOTHING_ON_CLOSE
    HIDE_ON_CLOSE
    DISPOSE_ON_CLOSE
    EXIT_ON_CLOSE
class Beispiel62_{
    public static void main(String[] args) throws Exception{
        final JFrame f = new JFrame("Juhu -- mein erstes Swing Fenster");
        f.setBounds(100,100,400,300);
        f.setDefaultCloseOperation(JFrame.DO_NOTHING_ON_CLOSE);
        f.setVisible(true);
    }
}

- Basisklasse JWindwow
- JFrame und JDialog abgeleitet
- in der Regel werden nur JFrame und JDialog verwendet
- JFrame als Hauptklasse für alle möglichen Fenster
- JDialog wird für kurze Dialoge mit dem Benutzer verwendet

Graphikkontext
Streams für Zeichen Ein- und Ausgabe
    System.out.println("Das war einfach");
- out ist Objekt der Klasse PrintStream
- bietet Möglichkeiten zum Ausgaben von Zeichen: println
- Abstraktion von konkreten Ausgaberoutinen des BS
    Analogen zu PrintStream ist Graphics

Graphics ist verwenden zur Graphikausgabe
    Graphics g;
    ...
    g.drawLine(0,0,200,100);
-   zeichnet im Graphikkontext g eine Linie von (0,0) nach (200,100)
    g.drawLine(x1, y1, x2, y2);
    x1, y1 sind die Koordinaten des Startpunkts der Linie.
    x2, y2 sind die Koordinaten des Endpunkts der Linie.
-   Abstraktion von konkreten Ausgaberoutinen des BS:
    wie die Line auf dem Bildschirm erscheint, ist Aufgabe von Java

Hier entstehen sofort drei Fragen:
1.  Welche Operationen gibt es für einen Graphikkontext?
2.  Was sind das für Koordinaten (0,0) und (200,100)?
3.  Wie hängt ein Graphikkontext mit einem Fenster zusammen?

Welche Operationen gibt es für einen Graphikkontext?
Einfache graphische Objekte können ausgegeben werden:
-   Linien drawLine
-   Rechtecke drawRect
-   Rechtecke mit abgerundeten Ecken drawRoundRect
-   Polygone drawPolygon
-   Kreise drawOval
-   Kreisbögen drawArc
-   Text

Zeichenbefehle der Graphics Klasse
Linien- oder Füllmodus?
drawLine                -   ---
drawRect                -   fillRect
drawRoundRect           -   fillRoundRect
drawPolygon             -   fillPolygon
drawPolyline            -   fillPolyline
drawOval                -   fillOval
drawAry                 -   fillArc

Was sind das für Koordinaten (0,0) und (200,100)?
- Graphikkontext hat ein 2-dimensionales Koordinatensystem:
    - Ursprungspunkt (0,0) liegt links oben
    - x-Werte erstrecken sich nach rechts
    - y-Werte nach unten
    - g.drawLine(x1, y1, x2, y2);
          x1, y1 sind die Koordinaten des Startpunkts der Linie.
          x2, y2 sind die Koordinaten des Endpunkts der Linie.

Beispiel 2
- Zu jedem Fenster gibt es einen Graphikkontext
- getGraphics() liefert diesen Graphikkontext

package vl_java;
import javax.swing.*;
import java.awt.*;                              // für die Klasse Graphics
class VL_01_Beispiel2 {
    public static void main(String[] args) {
        JFrame frame = new JFrame("Mein erstes Fenster");
        frame.setSize(400,300);
        frame.setVisible(true);
        Graphics g = frame.getGraphics();
        g.drawLine(0,0,200,100);
    }
}

Problem:
- Die Linie wird nicht gezeichnet
- wurde sie doch gezeichnet, geht sie wieder verloren

Erklärung:
- ein Graphikkontext merkt sich seinen Inhalt nicht
- beim Neuzeichnen des Fensters sind die Informationen verloren

Ein genaurerer Blick auf JFrame
- ein Fenster in Swing besteht aus mehreren Teilen
- i.A. ist die ContentPane interessant, da man sie sieht

Zeichnen in einem JFrame
- MenuPane:     enthält das Menu
- ContentPane:  der freie Fensterbereich zum Zeichnen
- GlassPane:    unsichtbare Schicht über dem Fenster; kann verwendet werden, um Low-Level Events abzufragen,
                um z.B. Mouseevents für alle Componente zu bearbeiten

class JFrame ... {
    public JRootPane getRootPane();
    public Container getContentPane();
    public JLayeredPane getLayeredPane();
    public Component getGlassPane();
    ...
}

Allgemeines Vorgehen:
- eigene Klasse von JComponent ableiten
- in diese Klasse wird gezeichnet (paintComponent-Methode überlagern, da die paint-Methode selber von Swing verwendet wird)
- Objekt dieser Klasse zu dem ContentPane mittels der add-Methode hinzufügen

Die paintComponent(Graphics g) Methode

-   Wann muss ein Fenster (oder ein Teil) neu gezeichnet werden?
        - beim ersten Mal
        - immer, wenn ein Teil verdeckt war und wieder sichtbar wird
        - unter Umständen häufiger (man kann nie wissen ...)
-   die paintComponent(Graphics g) Methode der Fensterelemente wird aufgerufen

import javax.swing.*;
import java.awt.*;
class MyComponent extends JComponent{
    @Override
    public void paintComponent(Graphics g){
        g.drawLine(0,0,200,100);
    }
}
class VL_01_Beispiel3 extends JFrame {
    public static void main(String[] args){
        JFrame j = new JFrame("Mein erstes Fenster");
        j.add(new MyComponent());
        j.setSize(400,300);
        j.setVisible(true);
    }
}

getContentPane(): Früher war alles anders
- in alten Versionen von Java (< 1.5) musste man unter Swing der ContentPane die Elemente hinzufügen
- ein Hinzufügen zum Swing Fenster erzeugte ein Laufzeitfehler

class Beispiel62_4{
    public static void main(String[] args) throws Exception{
        final JFrame f = new JFrame("Juhu -- mein erstes Swing Fenster");
        f.setBounds(100,100,400,300);
        f.getContentPane().add(new MyContent());        // WICHTIG: in alten Java Versionen die ContentPane verwenden
        f.setVisible(true);
    }
}

________________________________________________________________________________________________________________________
                Vorlesung 2 - Aufbau von Programmen mit Grafikanteil
- bisher:
Programme waren recht kurz und übersichtlich
- zukünftig:
Programme mit Grafikanteil werden deutlich umfangreicher und komplizierter
- daher:
Programme brauchen eine Architektur, die die verschiedenen Anteile des Programms aufteilt,
strukturiert und koordiniert
- Lösung:
Model - View - Controller (MVC) Konzept

Controller kennt View und Model
View kennt Model, und beobachtet Controller
Model beobachtet View

Beispiel: ein Programm, dass
          - ein Fenster öffnet
          - immer zufällig zwei Koordinaten produziert
          - im Fenster eine Linie zwischen diesen beiden Koordinaten zieht

package vl_java;
import javax.swing.*;
import java.awt.*;
class Model{
    int m_maxX;                 // *
    int m_maxY;                 // *
    int m_X1,m_X2,m_Y1,m_Y2;    // * Die Daten des Modells
    Model(int maxX,int maxY){
        this.m_maxX = maxX;
        this.m_maxY = maxY;
    }
    void genNewKoor(){          // Das Modell kann nur neue Daten erzeugen
        this.m_X1 = (int)(Math.random() * m_maxX);
        this.m_X2 = (int)(Math.random() * m_maxX);
        this.m_Y1 = (int)(Math.random() * m_maxY);
        this.m_Y2 = (int)(Math.random() * m_maxY);
    }
}
class View extends JComponent{
    private Model m_Mod;        // Die Ansicht kennt das Modell
    View(Model mod){            // Zum Zeichnen wird auf das Model nur lesend zugegriffen
        this.m_Mod = mod;
    }
    @Override
    public void paintComponent(Graphics g){
        g.drawLine(this.m_Mod.m_X1,this.m_Mod.m_Y1,this.m_Mod.m_X2,m_Mod.m_Y2);
    }
}
class Controller{
    private Model m_Mod;        // *
    private View m_View;        // * Der Controller kennt nicht nur das Modell und die Ansicht ...
    Controller(){
        this.m_Mod = new Model(300,200);    // ... sondern erzeugt sie auch (muss aber nicht sein)
        this.m_View = new View(this.m_Mod);
        JFrame j = new JFrame();
        j.add(m_View);
        j.setSize(this.m_Mod.m_maxX,this.m_Mod.m_maxY);
        j.setVisible(true);
    }
    void simulate(){
        while(true){
            try{Thread.sleep(500);}
            catch(InterruptedException e){}
            this.m_Mod.genNewKoor();
            this.m_View.repaint();      // Der Controller verändert nicht die Daten, bewirkt aber die Veränderungen
        }
    }
}
public class VL_02_Beispiel4 {
    public static void main(String[] args) throws Exception{
        Controller c = new Controller();        // *
        c.simulate();                           // Das Hauptprogramm erzeugt nur noch den Controller und startet ihn
    }
}

- bei kleineren Grafikprogrammen werden Controller und View auch zusammengefasst
  Controller/View  <-> Model

- gleiches Beispiel
  - das Model ändert sich nicht
  - der Controlleranteil geht in die View ein

package vl_java;
import javax.swing.*;
import java.awt.*;
class ViewBeispiel5 extends JComponent{
    Model m_Mod = new Model(300,200);   // View/Controller erzeugt das Model ...
    public void paintComponent(Graphics g){
        g.drawLine(this.m_Mod.m_X1,this.m_Mod.m_Y1,this.m_Mod.m_X2,this.m_Mod.m_Y2);
    }
    void simulate(){                        // ... und enthält auch den Kontrollanteil
        while(true){
            try{Thread.sleep(500);}
            catch(InterruptedException e){}
            this.m_Mod.genNewKoor();
            repaint();
        }
    }
}
public class VL_02_Beispiel5 {
    public static void main(String[] args){
        JFrame j = new JFrame();
        ViewBeispiel5 v = new ViewBeispiel5();
        j.add(v);
        j.setSize(v.m_Mod.m_maxX,v.m_Mod.m_maxY);
        j.setVisible(true);
        v.simulate();
    }
}
________________________________________________________________________________________________________________________
                Text schreiben in Fenstern
Dazu gibt es u.a. die Methode:
class Graphics ...
    ...
    public void drawString(String str, int x, int y);       // schreibt str an die Position (x, y);
- Schreibt den String str im Fenster "an der Position (x, y)"
- verwendet den Standradfont
- verwendet die Standardfarbe

package vl_java;
import javax.swing.*;
import java.awt.*;
class Content extends JComponent{
    @Override
    public void paintComponent(Graphics g){
        String strText = new String("Mein\n Text");
        g.drawString(strText,50,100);
        g.drawChars(strText.toCharArray(),1,strText.length()-1,50,120);
        g.drawBytes(strText.getBytes(),5,strText.length()-5,80,140);
    }
}
public class VL_02_Beispiel6 {
    public static void main(String[] args){
        JFrame j = new JFrame();
        j.add(new Content());
        j.setSize(400,300);
        j.setVisible(true);
    }
}
________________________________________________________________________________________________________________________
                Fonts
- Der Standardfont wird gesetzt durch setFont
    public void setFont(Font font);
- Der Standardfont kann abgefragt werden durch getFont
    public Font getFont();
- Neue Fonts werden mittels des Konstruktors erzeugt
    Font(String name, int style, int size);
    - name:     Name des Fonts
    - style:    Stil des Fonts (Font.PLAIN, Font.BOLD, Font.ITALIC),
    - size:     gibt die Größe in Punkte an
    VORSICHT: nicht style und size verwechseln

Welche Namen sind erlaubt?
    • SansSerif (früher Helvetica)
    • Serif (früher TimesRoman)
    • Monospaced (früher Courier)

    • Diese Fonts sollten auf allen JAVA Systemen vorhanden sein.
    • Darüber hinaus gibt es noch weitere Fonts, die aber nicht auf
      jedem System verfügbar sind.
    • Daher kann Ihr Programm u.U. auf einem anderen System die
      Schriften nicht richtig darstellen, wenn Sie andere Fonts
      verwenden

Welche Stile sind erlaubt?
    • Font.PLAIN (Standardfont)
    • Font.BOLD (Fett)
    • Font.ITALIC (Kursiv)

    Font.BOLD | Font.ITALIC erzeugt kursiven Fettdruck

package vl_java;
import javax.swing.*;
import java.awt.*;
class Content extends JComponent{
    @Override
    public void paintComponent(Graphics g){
        String strText = new String("Mein\n Text");
        g.drawString(strText,50,100);
        g.setFont(new Font("Serif",Font.BOLD|Font.ITALIC,20));
        g.drawChars(strText.toCharArray(),1,strText.length()-1,50,120);
        g.setFont(new Font("Monospaced",Font.ITALIC,50));
        g.drawBytes(strText.getBytes(),5,strText.length()-5,80,140);
    }
}
public class VL_02_Beispiel6 {
    public static void main(String[] args){
        JFrame j = new JFrame();
        j.add(new Content());
        j.setSize(400,300);
        j.setVisible(true);
    }
}
________________________________________________________________________________________________________________________
                Verfügbare Fonts
Die Klasse GraphicsEnvironment hilft einem, alle verfügbaren Fonts zu ermitteln.

class GraphicsEnvironment
    ...
    public static GraphicsEnvironment getLocalGraphicsEnvironment();
    public String[] getAvailableFontFamilyNames();
    ...

public void paintComponent(Graphics g){
    GraphicsEnvironment ge = GraphicsEnvironment.getLocalGraphicsEnvironment();
    String[] arFonts = ge.getAvailableFontFamilyNames();
    for(int i = 0; i < arFonts.length; ++i){
        g.setFont(new Font(arFonts[i],Font.PLAIN,12));
        g.drawString(arFonts[i],10,getInsets().top + (i+1) * 12);
    }
}
________________________________________________________________________________________________________________________
                Farben
Farben werden in JAVA in zwei Modellen dargestellt:
- RGB Farbmodell: additive Farbmischung von Rot, Grün, Blau
- HSB Farbmodell: drei Parameter: Farbton, Intensität,
JAVA unterstützt die Konvertierung zwischen diesen Modellen
im Folgenden: RGB Farbmodell

Farben in JAVA in Klasse Color repräsentiert
public Color(int red, int green, int blue);

Erzeugt eine Farbe mit den angegebenen Farbanteilen. red, green
und blue müssen zwischen 0 und 255 liegen. 0 bedeutet kein
Anteil, 255 bedeutet maximaler Anteil.

Color(255,255,255)
Color(255,0,0)
Color(255,255,0)

public Color(float red,float green,float blue);

Erzeugt eine Farbe mit den angegebenen Farbanteilen. red, green
und blue müssen zwischen 0.0 und 1.0 liegen. 0.0 bedeutet kein
Anteil, 1.0 bedeutet maximaler Anteil.

Color(1.0,1.0,1.0) Weiß
Color(1.0,0.0,0.0) Rot
Color(1.0,1.0,0.0) Gelb

Vordefinierte Farben:

class Color
    ...
    public static Color white;
    public static Color lightGray;
    public static Color gray;
    public static Color darkGray;
    public static Color black;
    public static Color red;
    public static Color blue;
    public static Color green;
    public static Color yellow;
    public static Color magenta;
    public static Color cyan;
    public static Color orange;
    public static Color pink;
    ...

Informationen über Farben:
class Color
    ...
    public int getRed();
    public int getGreen();
    public int getBlue();
    ...
liefert den Rot-, Grün- bzw. Blauanteil einer Farbe.

Verwenden von Farben
class Graphics
    ...
    public void setColor(Color c);
    public Color getColor();
    ...
- g.setColor(Color.red) setzt aktuelle Zeichenfarbe auf Rot.
- g.getColor() liefert aktuelle Zeichenfarbe

package vl_java;
import javax.swing.*;
import java.awt.*;
class ContentBeispiel9 extends JComponent{
    public void paintComponent(Graphics g){
        for(int i = 0; i < 256; ++i){
            for(int j = 0; j < 256; ++j){
                g.setColor(new Color(i,j,0));
                g.drawLine(i,j,i,j);
                g.setColor(new Color(i,j,255));
                g.drawLine(i+256,j,i+256,j);
            }
        }
    }
}
public class VL_02_Beispiel9 {
    public static void main(String[] args){
        JFrame j = new JFrame();
        j.add(new ContentBeispiel9());
        j.setSize(550,300);
        j.setVisible(true);
    }
}
________________________________________________________________________________________________________________________
                Systemfarben
class SystemColor
    ...
    public static Color desktop;
    public static Color control;
    ...
- desktop ist die Hintergrundfarbe des Desktops.
- control ist die Hintergrundfarbe für Dialogelemente.

Diese Farben werden zur Laufzeit ermittelt.

public void paintComponent(Graphics g){
    g.setColor(SystemColor.desktop);
    g.fillRect(0,0,100,100);
}
________________________________________________________________________________________________________________________
                Vorder- und Hintergrundfarbe

Zu jeder Komponente kann die Standardfarbe für den Vorder- und Hintergrund gesetzt werden

class JComponent{
    ...
    public void setBackground(Color c);
    public void setForeground(Color c);
    ...
}

package vl_java;
import javax.swing.*;
import java.awt.*;
class ContentBeispiel16 extends JComponent{
    @Override
    public void paintComponent(Graphics g){
        g.fillRect(40,40,50,50);
    }
}
public class VL_02_Beispiel16 {
    public static void main(String[] args){
        JFrame j = new JFrame("Jetzt mal mit anderen Farben");
        j.add(new ContentBeispiel16());
        j.setBounds(200,300,400,200);
        j.getContentPane().setForeground(Color.cyan);
        j.getContentPane().setBackground(Color.pink);
        // Wichtig: nicht das Fenster, sondern der Inhalt muss geändert werden
        j.setVisible(true);
    }
}
________________________________________________________________________________________________________________________
                Vorlesung 3 - Aufruf von Fenstern
public JFrame();
dadurch wird ein einfaches Fenster mit Rahmen und leerer Titelleiste erzeugt

public JFrame(String strTitle);
erzeugt ein einfaches Fenster, mit Rahmen und Titelleiste, sowie den String strTitle

public JWindow(JFrame parent);
erzeugt ein einfaches Fenster ohne Rahmen und ohne Titleleiste

public static void main(String[] args){
    JFrame top = new JFrame();
    JFrame top2 ) new JFrame("juhu");
    top.setSize(800,600);
    tio.setVisible(true);
    top2.setSize(800,600);
    top2.setVisible(true);
    JWindow w = new JWindow(top);
    w.setSize(400,300);
    w.setVisible(true);
}
...
JFrame top = new JFrame();
JWindow w = new JWindow(top);
...
Frage: Warum braucht ein einfaches Fenster(JWindow) einen Vater-JFrame?
Weil es ein eigenes, unabhängiges Fenster darstellen soll, das jedoch
keinen eigenen Rahmen, keine Menüleiste und keine Titelleiste hat.

Erzeugen eines Fensters, z.B.:
    JFrame f = new JFrame();
sichtbar machen, d.h. auf dem Bildschirm anzeigen:
    f.setVisible(true);
________________________________________________________________________________________________________________________
            Schließen von Fenstern
Fenster werden durch den Befehl
    setVisible(false)
geschlossem, d.h. unsichtbar gemacht.
WICHTIG: Das Fenster existiert noch im Speicher und kann jederzeit wieder angezeigt werden.

package vl_java;
import javax.swing.*;

public class VL_03_Beispiel12 {
    public static void main(String[] args) {
        JFrame f = new JFrame();
        f.setSize(700,500);
        f.setVisible(true);
        try {
            Thread.sleep(700);
        } catch (java.lang.InterruptedException i) {}
        f.setVisible(false);
        try {
            Thread.sleep(700);
        } catch (java.lang.InterruptedException i) {}
        f.setVisible(true);
    }
}
________________________________________________________________________________________________________________________
            Löschen von Fenstern
Fenster werden durch den Befehl
    dispose();
gelöscht, d.h. unsichtbar gemacht und aus dem Speicher gelöscht.

package vl_java;
import javax.swing.*;
import java.awt.*;
public class VL_03_Beispiel13 extends JComponent {
    private int m_iCurrentNum = 0;
    public void countDown(JFrame f) {
        for(m_iCurrentNum = 10;m_iCurrentNum > 0;--m_iCurrentNum) {
            try {Thread.sleep(1000);}
            catch (InterruptedException e) {}
            f.repaint();
        }
        f.dispose();
    }
    public static void main(String[] args) {
        JFrame f = new JFrame();
        VL_03_Beispiel13 b = new VL_03_Beispiel13();
        f.add(b);
        f.setSize(400,300);
        f.setVisible(true);
        b.countDown(f);
        System.out.println("Schluss");
    }
    public void paintComponent(Graphics g){
        g.setFont(new Font("Serif",Font.BOLD + Font.ITALIC,80));
        FontMetrics actualMetric = g.getFontMetrics();
        String strText = Integer.toString(m_iCurrentNum);
        final int fiTextWidth = actualMetric.stringWidth(strText);
        final int fiTextHeight = actualMetric.getHeight();
        final int fiTextBottom = actualMetric.getDescent() + actualMetric.getLeading();
        final int fiVisibleWidth = getSize().width-getInsets().left-getInsets().right;
        final int fiVisibleHeight = getSize().height-getInsets().top-getInsets().bottom;
        g.clearRect(0,0,getBounds().width,getBounds().height);
        g.drawString(strText,
                getInsets().left + (fiVisibleWidth - fiTextWidth) / 2,
                getInsets().top + (fiVisibleHeight + fiTextHeight) / 2 - fiTextBottom);
        System.out.println(m_iCurrentNum);
    }
}
________________________________________________________________________________________________________________________
            Bildschirm- und Fenstergröße und -position
class Toolkit
    ...
    public Dimension getScreenSize();       // Bildschirmgröße
    ...

class JComponent
    ...
    public void setSize(int width, int height);     // Fenstergröße
    public void setSize(Dimension d);

    public void setLocation(int x, int y);          // Fensterposition
    public void setLocation(Point p);

    public void setBounds(int x, int y, int width, int height);     // Fenstergröße und -position
    public void setBounds(Rectangle r);
    ...

package vl_java;
import javax.swing.*;
import java.awt.*;
class Content_VL_03_Beispiel14 extends JComponent{
    @Override
    public void paintComponent(Graphics g){
        g.setColor(Color.red);
        g.setColor(Color.white);
        g.fill3DRect(0,0,300,200,true);
    }
}
public class VL_03_Beispiel14 {
    public static void main(String[] args){
        JWindow w = new JWindow(new JFrame());
        w.add(new Content_VL_03_Beispiel14());
        Dimension dim = w.getToolkit().getScreenSize();
        w.setLocation(dim.width/2-150,dim.height/2-100);
        w.setSize(300,200);
        w.setBounds(dim.width/2-150,dim.height/2-100,300,200);
        w.setVisible(true);
    }
}
________________________________________________________________________________________________________________________
            Anzeigezustand von Fenstern
- Fenster können "normal" oder "als Symbol" anzeigt werden
- Setzen des Anzeigezustands
    public synchronized void setExtendedState(int state);
- mögliche Zustände
    - Frame.ICONIFIED
    - Frame.NORMAL
________________________________________________________________________________________________________________________
            Die Titleleiste
- Der Inhalt der Titelleiste kann im Konstruktor von Frame gesetzt werden.
    - public JFrame(String strTitle);
- Während des Programms kann der Title umgesetzt werden,
    - public void setTitle(String strTitle);
- und abgefragr werden.
    - public String getTitle();
________________________________________________________________________________________________________________________
            Das Icon-Image
- Werden Fenster "als Symbol" dargestellt, repräsentiert ein Icon das Fenster.
- Das Icon wird gesetzt durch:
    - public void setIconImage(Image image);
________________________________________________________________________________________________________________________
            Images
- Images können über das Toolkit geladen werden
    class Toolkit
        ...
        public abstract Image getImage(String strFileName);
        public abstract Image getImage(URL url);
- Images werden im Graphikontext gedruckt durch:
    class Graphics
        ...
        public void drawImage(Image image,...)
        ...
________________________________________________________________________________________________________________________
            Der Mauscursor
- Die Form des Mauscursors kann für jede Component eigenständig definiert werden.
    class JComponent
        ...
        public void setCursor(Cursor cursor);
        ...
- Die Klasse für die unterschiedlichen Mauscursor.
    class Cursor
        ...
        public Cursor(int type);
        public static Cursor getPredefinedCursor(int type);
        final public int CROSSHAIR_CURSOR;
        final public int DEFAULT_CURSOR;
        final public int E_RESIZE_CURSOR;
        ...
WICHTIG: nicht neue Instanzen von Cursor erzeugen, sondern mittels getPredifinedCursor(int type)
einen anderen Cursor wählen.

package vl_java;
import javax.swing.*;
import java.awt.*;
public class VL_03_Beispiel15 {
    public static void main(String[] args){
        JFrame f = new JFrame();
        f.setTitle("Es geht auch anders");
        Dimension dim = f.getToolkit().getScreenSize();
        f.setBounds(300,200,dim.width/2-150,dim.height/2-100);
        Image img = f.getToolkit().getImage("start.gif");
        f.setIconImage(img);
        f.setCursor(Cursor.getPredefinedCursor(Cursor.CROSSHAIR_CURSOR));
        f.setVisible(true);
        f.setExtendedState(Frame.ICONIFIED);
    }
}
________________________________________________________________________________________________________________________
            Vorlesung 4 - Event-Handling
Situation: Ein Button eines Dialogs wird gedrückt.
Frage:     Was passiert in dieser Situation?

1.  An den Button wird eine Nachricht geschickt, dass er gedrückt wird.
2.  Der Button schaut nach, ob er auf das Drücken reagieren soll.
3.  Wenn er reagieren soll, wird die Nachricht an den "Sachbearbeiter" weitergeschickt.

Ereignis: Benutzer drückt Button
Window Manager -> (Nachricht "Du wurdest gedrückt") -> Objekt der Klasse JButton -> (schaut nach, ob auf diese Nachticht reagiert werden soll)
-> Ja -> Objekt der Klasse "Objekt der Klasse "Reagierer" verarbeitet Event
-> Nein -> "Es passiert nichts"

Beim Event-Handling sind genau die folgenden Objekte beteiligt:
1. das Objekt, dass das Event auslöst, die Ereignisquelle (Event Source), - siehe Objekt der Klasse JButton
2. das Objekt, dass das Event verarbeitet, der Ereignisempfänger (Event Listener), - siehe Objekt der Klasse "Reagierer" verarbeitet Event

1. Frage: Wie kann der Button wissen, auf welche Ereignisse er reagieren soll?
2. Frage: Woher weiß der Button, welches Objekt das Ereignis verarbeitet?

Antwort: Das Objekt zum Verarbeiten des Events wird bei dem Button zu genau diesem Event registriert.
________________________________________________________________________________________________________________________
            Vorlesung 4 - Beispiel 22

package vl_java;
import javax.swing.*;
import java.awt.*;
import java.awt.event.*;
class Reagierer implements ActionListener{
    int j = 0;
    public void actionPerformed(ActionEvent e){
        System.out.println(++j + " juhu");
    }
}
class MyButton extends JButton{
    public MyButton(){
        super("Drück mich!");
        addActionListener(new Reagierer());
    }
}
public class VL_04_Beispiel22 {
    public static void main(String[] args){
        JFrame f = new JFrame();
        f.setBounds(100,100,300,200);
        f.add(new MyButton());
        f.setVisible(true);
    }
}

package vl_java;
import javax.swing.*;
import java.awt.*;
import java.awt.event.*;
public class VL_04_Beispiel22_3 {
    public static void main(String[] args){
        JFrame j = new JFrame();
        j.add(new JButton("Drück mich"){
            {   addActionListener(new ActionListener(){
                    public void actionPerformed(ActionEvent e){
                        System.out.println("juhu");
                    }
                });
            }
        });
        j.setBounds(100,100,300,200);
        j.setVisible(true);
    }
}
________________________________________________________________________________________________________________________
            Event-Typen

Welche Ereignisse (Events) gibt es, auf die man reagieren kann?
Event Object
    AWT Object

AWT Object
    Component Event, Action Event, Adjustment Event, Item Event, Text Event

Component Event
    Focus Event, Input Event, Container Event, Window Event

Input Event
    Key Event, Mouse Event



            Action Ereignisse:
Listener-Interface              ActionListener
Registrierungsmethode           void addActionListener(ActionListener l);
Mögliche Ereignisquellen        JButton, JList, JMenuItem, ITextField
Ereignismethode                 public void actionPerformed(ActionEvent e);
Bedeutung                       eine Aktion wurde ausgelöst, z.B. der Button wurde gedrückt,
                                ein Menu wurde ausgewählt, ein Text wurde in dem Textfeld eingegeben.

            Window Ereignisse
Listener-Interface              WindowListener
Registrierungsmethode           void addWindowListener(WindowListener l);
Mögliche Ereignisquellen        JDialog, JFrame
Ereignismethode                 void windowActivated(WindowEvent e);
                                void windowClosed(WindowEvent e);
                                void windowClosing(WindowEvent e);
                                void windowDeactivated(WindowEvent e);
                                void windowDeiconified(WindowEvent e);
                                void windowIconified(WindowEvent e);
                                void windowOpened(WindowEvent e);
________________________________________________________________________________________________________________________
            Window Ereignisse: Beispiel
JFrame j = new JFrame();
j.setBounds(100,100,300,200);
j.addWindowListener(new WindowListener(){
    public void windowActivated(WindowEvent e){}
    public void windowClosed(WindowEvent e){}
    public void windowClosing(WindowEvent e){
        System.exit(0);
    }
    public void windowDeactivated(WindowEvent e){}
    public void windowDeiconified(WindowEvent e){}
    public void windowIconified(WindowEvent e){}
    public void windowOpened(WindowEvent e){}
});
j.setVisible(true);     // Was ist das Problem?
________________________________________________________________________________________________________________________
            Adapterklassen
Problem mit großen Listener Interfaces:
Es müssen immer alle Methoden implementiert werden, obwohl die meisten leer sind.
Lösung:
Es gibt entsprechende Adapterklassen zu allen Listener Interfaces, die alle Methoden mit leeren
Methodenrümpfen implementiert. Verwenden Sie die entsprechenden Adapterklasse
und überschreiben Sie nur die Methode, die Sie brauchen.

kanonische Namen: WindowListener <-> WindowAdapter

public Interface WindowListener{
    public void windowActivated(WindowEvent e);
    public void windowClosed(WindowEvent e);
    public void windowClosing(WindowEvent e);
    public void windowDeactivated(WindowEvent e);
    public void windowDeiconified(WindowEvent e);
    public void windowIconified(WindowEvent e);
    public void windowOpened(WindowEvent e);
}

public class WindowAdapter implements WindowListener{
    public void windowActivated(WindowEvent e) {}
    public void windowClosed(WindowEvent e) {}
    public void windowClosing(WindowEvent e) {}
    public void windowDeactivated(WindowEvent e) {}
    public void windowDeiconified(WindowEvent e) {}
    public void windowIconified(WindowEvent e) {}
    public void windowOpened(WindowEvent e) {}
}
________________________________________________________________________________________________________________________
            Beispiel 23
Window Ereignsisse: Beispiel mit Adapterklasse

package vl_java;
import javax.swing.*;
import java.awt.event.*;
public class VL_04_Beispiel23_1 {
    public static void main(String[] args){
        JFrame j = new JFrame();
        j.setBounds(100,100,300,200);
        j.addWindowListener(new WindowAdapter(){
            public void windowClosing(WindowEvent e){
                j.dispose();
            }
            public void windowIconified(WindowEvent e){
                j.setExtendedState(JFrame.NORMAL);
            }
        });
        j.setVisible(true);     // Deutlich übersichtlicher!
    }
}
________________________________________________________________________________________________________________________
            Gefahr bei Adapterklassen
public static void main(String[] args){
    JFrame j = new JFrame();
    j.setBounds(100,100,300,200);
    j.addWindowListener(new WindowAdapter(){
        public void windowclosing(WindowEvent e){
            j.dispose();
        }
    });
    j.setVisible(true);
}

Problem:
- in WindowAdapter ist windowClosing bereits implementiert
- wir definieren windowclosing: eine neue Methode, die nichts mit windowClosing zu tun hat
- BS ruft windowClosing, nicht unsere windowclosing auf

Lösung:
- Compiler mittels Pragmas sagen, dass eine Methode überlagert werden soll
- dann kann der Compiler Rechtsschreibfehler entdecken

class Beispiel23_3{
    public static void main(String[] args){
        JFrame j = new JFram();
        j.setBounds(100,100,300,200);
        j.addWindowListener(new WindowAdapter(){
            @Override // Sagt, dass nachfolgende Methode eine vorhandene Methode überlagern soll
            public void windowclosing(WindowEvent e){
                j.dispose();
            }
        });
        j.setVisible(true);
    }
}
________________________________________________________________________________________________________________________
            Event-Typen (Fort.)
Mouse Ereignisse
Listener-Interface              MouseListener
Registrierungsmethode           void addMouseListener(MouseListener l);
Mögliche Ereignisquelle         JComponent
Ereignismethode                 void mouseClicked(MouseEvent e);
                                void mouseEntered(MouseEvent e);
                                void mouseExited(MouseEvent e);
                                void mousePrssed(MouseEvent e);
                                void mouseReleased(MouseEvent e);

package vl_java;
import javax.swing.*;
import java.awt.event.*;
public class VL_04_Beispiel24 {
    public static void main(String[] args){
        JFrame j = new JFrame();
        j.setBounds(100,100,300,200);
        j.setVisible(true);
        j.addMouseListener(new MouseAdapter(){
            @Override
            public void mouseEntered(MouseEvent e){
                System.out.println("drin");
            }
            @Override
            public void mouseClicked(MouseEvent e){
                System.out.print("mouse click");
                System.out.print(" shift: " + (e.isShiftDown() ? "yes" : "no"));
                System.out.print(" control: " + (e.isControlDown() ? "yes" : "no "));
                System.out.print(" meta: " + (e.isAltDown() ? "yes" : "no "));
                System.out.print(" Button: " + (e.getButton() == MouseEvent.BUTTON1
                                            ? "links"
                                            : e.getButton() == MouseEvent.BUTTON2
                                            ? "mitte" : "rechts"));
            }
        });
    }
}
________________________________________________________________________________________________________________________
            Vorlesung 5
MouseMotion Ereignisse

Listener-Interface          -       MouseMotionListener
Registrierungsmethode       -       void addMouseMotionListener(MouseMotionListener l);
Mögliche Ereignisquellen    -       JComponent
Ereignismethode             -       void mouseDragged(MouseEvent e);
                                    void mouseMoved(MouseEvent e);
Bedeutung                   -       Die Maus wurde bei gedrückter Maustaste bewegt (mouseDragged) bzw.
                                    bei nicht gedrückter Maustastte (mouseMoved)
Beispiel 24_1

package vl_java;
import javax.swing.*;
import java.awt.event.*;
public class VL_04_Beispiel24_1 {
    public static void main(String[] args){
        JFrame j = new JFrame();
        j.setBounds(100, 100, 300, 200);
        j.addMouseMotionListener(new MouseMotionAdapter(){
            @Override
            public void mouseMoved(MouseEvent e){
                System.out.println(e.getPoint());
            }
        });
        j.setVisible(true);
    }
}

Beispiel 24_2

package vl_java;
import javax.swing.*;
import java.awt.*;
import java.awt.event.*;
public class VL_04_Beispiel24_2 extends JComponent{
    Point mPoint;
    Image mImg;
    public VL_04_Beispiel24_2(){
        mImg = getToolkit().getImage("src/vl_java/ZZ5H.gif");
        addMouseMotionListener(new MouseMotionAdapter(){
            @Override
            public void mouseDragged(MouseEvent e){
                mPoint = e.getPoint();
                repaint();
            }
        });
    }
    public void paintComponent(Graphics g){
        if(mImg != null && mPoint != null)
            g.drawImage(mImg, mPoint.x, mPoint.y, this);
    }
    public static void main(String[] args){
        JFrame j = new JFrame();
        j.add(new VL_04_Beispiel24_2());
        j.setBounds(100, 100, 700, 500);
        j.setVisible(true);
    }
}
________________________________________________________________________________________________________________________
            Event-Typen (Fort.)
MouseWheel Ereignisse (ab JDK 1.4)

Listener Interface              -           MouseWheelListener
Registrierungsmethode           -           void addMouseWheelListener(MouseWheelListener l);
Mögliche Ereignisquellen        -           JComponent
Ereignismethode                 -           void mouseWheelMoved(MouseWheelEvent e);
Bedeutung                       -           Das Mausrad wurde bewegt.

Beispiel 24_3

package vl_java;
import javax.swing.*;
import java.awt.*;
import java.awt.event.*;
public class VL_04_Beispiel24_3 extends JComponent{
    int mY = 100;
    Image mImg;
    public VL_04_Beispiel24_3(){
        mImg = getToolkit().getImage("src/vl_java/ZZ5H.gif");
        addMouseWheelListener(new MouseWheelListener(){
            public void mouseWheelMoved(MouseWheelEvent e){
                mY += e.getWheelRotation();         // Liefert die Richtung zurück (immer 1 oder -1)
                mY += e.getUnitsToScroll();         // Liefert die Richtung und die Einheiten zurück (z.B. 3 oder -9)
                repaint();
            }
        });
    }
    public void paintComponent(Graphics g){
        if(mImg != null){
            int imageWidth = mImg.getWidth(this) / 2;
            g.drawImage(mImg, imageWidth, mY, this);
        }
    }
    public static void main(String[] args){
        JFrame f = new JFrame();
        f.add(new VL_04_Beispiel24_3());
        f.setBounds(100, 100, 700, 500);
        f.setVisible(true);
    }
}
________________________________________________________________________________________________________________________
            Event-Typen (Fort.)
Key Ereignisse

ListenerInterface           -           KeyListener
Registrierungsmethode       -           void addKeyListener(KeyListener l);
Mögliche Ereignisquellen    -           JComponent
Ereignismethode             -           void keyPressed(KeyEvent e);
                                        void keyReleased(KeyEvent e);
                                        void keyTyped(KeyEvent e);
Bedeutung                   -           Eine Taste wurde gedrückt (keyPressed), oder losgelassen (keyReleased) oder
                                        gedrückt und losgelassen (keyTyped)

package vl_java;
import javax.swing.*;
import java.awt.*;
import java.awt.event.*;
public class VL_04_Beispiel25 {
    public static void main(String[] args){
        JFrame j = new JFrame();
        j.addKeyListener(new KeyAdapter(){
            // Unterschied: Shift und Control Taste
            @Override
            public void keyTyped(KeyEvent e){
                System.out.println(e.getKeyChar());
            }
        });
        j.setBounds(100, 100, 300, 200);
        j.setVisible(true);
    }
}
________________________________________________________________________________________________________________________
            Event-Typen (Fort.)
Item Ereignisse

Listener Interface          -           ItemListener
Registrierungsmethode       -           void addItemListener(ItemListener l);
Mögliche Ereignisquellen    -           JCheckBox, JComboBox, JList, JCheckboxMenuItem
Ereignismethode             -           void itemStateChanged(ItemEvent e);
Bedeutung                   -           Der Zustand hat sich verändert

package vl_java;
import javax.swing.*;
import java.awt.*;
import java.awt.event.*;
public class VL_04_Beispiel29 {
    public static void main(String[] args){
        JFrame j = new JFrame();
        j.add(new JCheckBox("vielleicht"){
            {
                addItemListener(new ItemListener(){
                    public void itemStateChanged(ItemEvent e){
                        System.out.println(e.getStateChange() == ItemEvent.SELECTED);
                        System.out.println(e.getStateChange());
                        System.out.println(isSelected());
                    }
                });
            }
        });
        j.setBounds(100, 100, 300, 200);
        j.setVisible(true);
    }
}
________________________________________________________________________________________________________________________
            Event-Typen (Fort.)
Adjustment Ereignisse

ListenerInterface           -           AdjustmentListener
Registrierungsmethode       -           void addAdjustmentListener(AdjustmentListener l);
Mögliche Ereignisquellen    -           JScrollBar
Ereignismethode             -           void adjustmentValueChanged(AdjustmentEvent e);
Bedeutung                   -           Der Wert wurde geändert

package vl_java;
import javax.swing.*;
import java.awt.*;
import java.awt.event.*;
public class VL_04_Beispiel26 extends JFrame{
    MyScrollbar m_Red = new MyScrollbar();
    MyScrollbar m_Green = new MyScrollbar();
    MyScrollbar m_Blue = new MyScrollbar();
    class MyScrollbar extends JScrollBar {
        int m_iValue;
        MyScrollbar() {
            super(VERTICAL,0,1,0,256);
            addAdjustmentListener(new AdjustmentListener() {
                public void adjustmentValueChanged(AdjustmentEvent e) {
                    m_iValue = e.getValue();
                    setColor();
                }
            });
        }
    }
    public VL_04_Beispiel26() {
        setBounds(100,100,300,200);setLayout(new FlowLayout());
        add(m_Red);add(m_Green);add(m_Blue);
        setColor();setVisible(true);
    }
    public void setColor() {
        getContentPane().setBackground(new Color(m_Red.m_iValue,m_Green.m_iValue,m_Blue.m_iValue));
    }
    public static void main(String [] args) {
        new VL_04_Beispiel26();
    }
}

package vl_java;
import javax.swing.*;
import java.awt.*;
import java.awt.event.*;
public class VL_04_Beispiel26_1 extends JFrame implements AdjustmentListener {
    JScrollBar red = new JScrollBar(JScrollBar.VERTICAL, 0, 1, 0, 256);
    JScrollBar green = new JScrollBar(JScrollBar.VERTICAL, 0, 1, 0, 256);
    JScrollBar blue = new JScrollBar(JScrollBar.VERTICAL, 0, 1, 0, 256);
    public VL_04_Beispiel26_1(){
        setBounds(100,100, 300, 200);
        setLayout(new FlowLayout());
        add(red);
        add(green);
        add(blue);
        setVisible(true);
        red.addAdjustmentListener(this);
        green.addAdjustmentListener(this);
        blue.addAdjustmentListener(this);
    }
    public void adjustmentValueChanged(AdjustmentEvent e){
        getContentPane().setBackground(new Color(red.getValue(), green.getValue(), blue.getValue()));
    }
    public static void main(String[] args){
        new VL_04_Beispiel26_1();
    }
}
________________________________________________________________________________________________________________________
            Event-Typen (Fort.)
Focus Ereignisse

ListenerInterface           -           FocusListener
Registrierungsmethode       -           void addFocusListener(FocusListener l);
Mögliche Ereignisquellen    -           JComponent
Ereignismethode             -           void focusGained(FocusEvent e);
                                        void focusLost(FocusEvent e);
Bedeutung                   -           Eine Komponente erhält den Focus (focusGained)
                                        bzw. verliert ihn (focusLost).
________________________________________________________________________________________________________________________
            Event-Typen (Fort.)

Component Ereignisse

ListenerInterface           -           ComponentListener
Registrierungsmethode       -           void addComponentListener(ComponentListener l);
Mögliche Ereignisquellen    -           JComponent
Ereignismethode             -           void componentHidden(ComponentEvent e);
                                        void componentMoved(ComponentEvent e);
                                        void componentResized(ComponentEvent e);
                                        void componentShown(ComponentEvent e);
Bedeutung                   -           Eine Komponente wird verdeckt (setVisible(false)), bewegt,
                                        in der Größe verändert oder sichtbar (setVisible(true)) gemacht.

package vl_java;
import javax.swing.*;
import java.awt.event.*;
public class VL_04_Beispiel27 {
    public static void main(String[] args){
        JFrame j = new JFrame();
        j.addComponentListener(new ComponentAdapter(){
            @Override
            public void componentResized(ComponentEvent e){
                System.out.println("Resize: " + e);
            }
        });
        j.setBounds(100, 100, 300, 200);
        j.setVisible(true);
    }
}

package vl_java;
import javax.swing.*;
import java.awt.*;
import java.awt.event.*;
public class VL_04_Beispiel27_1 {
    public static void main(String[] args){
        JFrame f = new JFrame();
        f.setBounds(200, 200, 200, 200);
        f.setVisible(true);

        JFrame j = new JFrame();
        j.setBounds(100, 100, 300,200);
        j.addComponentListener(new ComponentAdapter(){
            @Override
            public void componentResized(ComponentEvent e){
                java.awt.Dimension dim = j.getSize();
                f.setSize(dim.width, dim.width);
            }
        });
        j.setVisible(true);
    }
}
________________________________________________________________________________________________________________________
            Event-Typen (Fort.)
Container Ereignisse

ListenerInterface           -           ContainerListener
Registrierungsmethode       -           void addContainerListener(ContainerListener l);
Mögliche Ereignisquellen    -           JContainer
Ereignismethode             -           void componentAdded(ContainerEvent e);
________________________________________________________________________________________________________________________
            Lambda Ausdrücke
Problem mit anonymen Klassen zur Implementierung der ActionListener:

    - immer wieder sehr viel Schreibarbeit
    - die komplette Deklaration der anonymen Klasse könnte der Compiler selber schreiben
    - daher ab Java 1.8: Lambda Ausdrücke (Begriff aus der funktionalen Programmierung)
    - nur noch der Inhalt der Funktion muss implementiert werden
    - nicht mehr implementiert werden muss:
        - Deklaration der anonymen Klasse
        - Deklaration der überlagerten Methode

- Bisher:
    ...
    addActionListener(
        new ActionListener(){   // *
            public void actionPerformed(ActionEvent e){ // *
                System.out.println("juhu");
            }   // *
        }   // * Alles überflüssig, da nichts anderes geschrieben werden kann (Ausnahme: 'e' für den Namen des Arguments)
    );

- mit Lambda Ausdrücken
    ...
    addActionListener(
        e ->
            System.out.println("juhu")  // WICHTIG: kein Semikolon hier !!!
    );

- Lambda Ausdrücke funktionieren nur bei Interfaces, die genau eine Methode enthalten
- sie funktionieren nicht bei
    - Interfaces mit mehreren Methoden
    - abstrakten Klassen
    - normalen Klassen
- solche Interfaces heißen "funktionale Interfaces" (sie spezifizieren im Wesentlichen eine Funktion)

package vl_java;
interface Juhu{
    public void doit();
}
public class VL_04_Beispiel29Lambda1 {
    public static void main(String[] args){
        Juhu j1 = new Juhu(){
            public void doit(){
                System.out.println("dies ist der alte Weg");
            }
        };
        Juhu j2 = () -> System.out.println("mit Lambda Ausdruck");  // ohne Parameter müssen leere Klammern gesetzt werden

        j1.doit();
        j2.doit();
    }
}

- die Methoden können auch mehrere Parameter haben

package vl_java;
interface Juhu2{
    public void doit(int i, float f);
}
public class VL_04_Beispiel29Lambda2 {
    public static void main(String[] args){
        Juhu2 j1 = new Juhu2(){
          public void doit(int i, float f){
              System.out.println("old school: i = " + i + " f = " + f);
          }
        };

        Juhu2 j2 = (i, f) -> System.out.println("Lambda: i = " + i + " f = " + f); // Mehrere Parameter müssen auch in Klammern gesetzt werden

        j1.doit(12, 34.6f);
        j2.doit(5, 7.8f);
    }
}

- mehrere Statements müssen in einem Block zusammengefasst werden

package vl_java;
interface Juhu3{
    public void doit(int i, int f);
}
public class VL_04_Beispiel29Lambda3 {
    public static void main(String[] args){
        Juhu3 j = (i1, i2) ->{  // * Block von hier
            System.out.println("jetzt kommt " + i1 + " mal die" + i2);
            for(int i = 0; i < i1; ++i)
                System.out.println(i2);
        };  // * bis hier
        j.doit(10, 13);
    }
}

- die Methoden können auch einen Rückgabewert haben

package vl_java;
interface Juhu4{
    public int doit(int i, int j);
}
public class VL_04_Beispiel29Lambda4 {
    public static void main(String[] args){
        Juhu4 j1 = (i1, i2) -> {return i1*i2;}; // obwohl nur ein Statement (return) muss es dennoch im Block stehen
        Juhu4 j2 = (x, y) -> x / y; // Spezialfall "Lambda Ausdrücke": das return kann weggelassen werden, dann auch ohne Block

        int a = j1.doit(12, 10);
        int b = j2.doit(12, 5);
        System.out.println(a + " " + b);
    }
}
________________________________________________________________________________________________________________________
    Vorlesung 5
MouseMotion Ereignisse ->
    Maus wurde bei gedrückter Maustaste bewegt (mouseDragged)
    bzw. bei nicht gedrükter Maustaste (mouseMoved)

package vl_java;
import javax.swing.*;
import java.awt.event.*;
public class VL_05_Beispiel24_1 {
    public static void main(String[] args){
        JFrame j = new JFrame();
        j.setBounds(100, 100, 300, 200);
        j.addMouseMotionListener(new MouseMotionAdapter(){
            @Override
            public void mouseMoved(MouseEvent e){
                System.out.println(e.getPoint());
            }
        });
        j.setVisible(true);
    }
}

package vl_java;
import java.awt.*;
import javax.swing.*;
import java.awt.event.*;
public class VL_05_Beispiel24_2 extends JComponent{
    Point mPoint;
    Image mImg;
    public VL_05_Beispiel24_2(){
        mImg = getToolkit().getImage("src/vl_java/ZZ5H.gif");
        addMouseMotionListener(new MouseMotionAdapter(){
            @Override
            public void mouseDragged(MouseEvent e){
                mPoint = e.getPoint();
                repaint();
            }
        });
    }
    public void paintComponent(Graphics g){
        if(mImg != null && mPoint != null)
            g.drawImage(mImg, mPoint.x, mPoint.y, this);
    }
    public static void main(String[] args){
        JFrame j = new JFrame();
        j.add(new VL_05_Beispiel24_2());
        j.setBounds(100, 100, 700, 500);
        j.setVisible(true);
    }
}


MouseWheel Ereignisse -> Das Mausrad wurde bewegt.

package vl_java;
import javax.swing.*;
import java.awt.*;
import java.awt.event.*;
public class VL_05_Beispiel24_3 extends JComponent{
    int mY = 100;
    Image mImg;
    public VL_05_Beispiel24_3(){
        mImg = getToolkit().getImage("src/vl_java/ZZ5H.gif");
        addMouseWheelListener(new MouseWheelListener(){
            public void mouseWheelMoved(MouseWheelEvent e){
                mY += e.getWheelRotation();
                mY += e.getUnitsToScroll();
                repaint();
            }
        });
    }
    @Override
    public void paintComponent(Graphics g){
        if(mImg != null)
            g.drawImage(mImg, getWidth() / 2, mY, this);
    }
    public static void main(String[] args){
        JFrame f = new JFrame();
        f.add(new VL_05_Beispiel24_3());
        f.setBounds(100, 100, 700, 500);
        f.setVisible(true);
    }
}

Key Ereignisse -> Eine Taste wurde gedrückt (keyPressed),
oder losgelassen (keyReleased) oder gedrückt und losgelassen (keyTyped).

package vl_java;
import java.awt.event.*;
import javax.swing.*;
public class VL_05_Beispiel25 {
    public static void main(String[] args){
        JFrame j = new JFrame();
        j.addKeyListener(new KeyAdapter(){
            // Unterschied: Shift und Control Taste
            @Override
            public void keyTyped(KeyEvent e){
                System.out.println(e.getKeyChar());
            }
        });
        j.setBounds(100, 100, 300, 200);
        j.setVisible(true);
    }
}

Item Ereignisse -> Der Zustand hat sich geändert.

package vl_java;
import javax.swing.*;
import java.awt.event.*;
public class VL_05_Beispiel29 {
    public static void main(String[] args){
        JFrame j = new JFrame();
        j.add(new JCheckBox("vielleicht"){
            {
                addItemListener(new ItemListener(){
                   public void itemStateChanged(ItemEvent e){
                       System.out.println(e.getStateChange() == ItemEvent.SELECTED);
                       System.out.println(e.getStateChange());
                       System.out.println(isSelected());
                   }
                });
            }
        });
        j.setBounds(100, 100, 300, 200);
        j.setVisible(true);
    }
}

Adjustment Ereignisse -> Der Wert wurde geändert
________________________________________________________________________________________________________________________
    Vorlesung 6 - Menus
Menus bestehen aus:
- Menuzeile
- Menu
- Menueinträge
- Trenner
- Beschleunigungstaste (Shortkey)

Sinn und Zweck
- Interaktion mit dem Benutzer
- Benutzer kann: 1. Aktion auswählen & anstoßen, einfache Daten in dem Programm setzen

Menus bestehen aus (Fort.)
- Hilfemenu
- Unternemu
- Menueintrag als Checkbox

Sonstiges:
- Programm hat maximal eine Menuleiste
- Menuleiste kann viele Menus haben (und ein Hilfemenu)
- Menu kann viele Menueinträge haben
- Menueintrag kann selber ein Menu sein
- Menueintrag kann einen Shortkey haben
- Checkbox kann ein Menueintrag sein

Menuleiste
- Erzeugt durch Klasse JMenuBar
- Wird durch setJMenubar-Methode von Frame dem Fenster hinzugefügt
- getInsets-Methode berücksichtigt dieses neue Element
- Menuleiste ohne Menus wird nicht dargestellt

package vl_java;
import javax.swing.*;
public class VL_06_Beispiel30_1 {
    public static void main(String[] args){
        JFrame j = new JFrame();
        j.setBounds(100, 100, 300, 200);
        JMenuBar menuBar = new JMenuBar();
        j.setJMenuBar(menuBar);
        j.setVisible(true);
    }
}

Menu
- Erzeugt durch Klasse JMenu
- Menu wird Menuleiste durch add-Methode hinzugefügt

package vl_java;
import javax.swing.*;
import java.awt.*;
public class VL_05_Beispiel30_2 {
    public static void main(String[] args){
        JFrame j = new JFrame();
        j.setBounds(100, 100, 300, 200);
        JMenuBar menuBar = new JMenuBar();
        menuBar.add(new JMenu("Datei"));
        j.setJMenuBar(menuBar);
        j.getContentPane().setBackground(java.awt.Color.PINK);
        j.setVisible(true);
    }
}

Menueinträge
- Erzeugt durch Klasse JMenuItem
- Menueintrag wird Menu durch add-Methode hinzugefügt
- Menueintrag kann auch direkt durch void add(String)-Methode von Menu erzeugt werden

package vl_java;
import javax.swing.*;
public class VL_05_Beispiel30_4 {
    public static void main(String[] args){
        JFrame j = new JFrame();
        j.setBounds(100, 100, 300, 200);
        JMenuBar menuBar = new JMenuBar();
        JMenu menu = new JMenu("Datei");
        menu.add(new JMenuItem("Neu"));
        menu.add("Beenden");
        menuBar.add(menu);
        j.setJMenuBar(menuBar);
        j.setVisible(true);
    }
}

Menueinträge (Fort.)
- Menueintrag kann selber ein Menu sein (Submenu)
- Submenu wird Menu durch add-Methode hinzugefügt

package vl_java;
import javax.swing.*;
public class VL_05_Beispiel30_5 {
    public static void main(String[] args){
        JFrame j = new JFrame();
        j.setBounds(100, 100, 300, 200);
        JMenuBar menuBar = new JMenuBar();
        JMenu menu = new JMenu("Datei");
        JMenu sub = new JMenu("Speichern");
        menu.add(new JMenuItem("Neu"));
        menu.add(sub);
        sub.add(new JMenuItem("..als HTML"));
        sub.add(new JMenuItem("..als Source"));
        menuBar.add(menu);
        j.setJMenuBar(menuBar);
        j.setVisible(true);
    }
}

- Menueintrag kann auch Checkbox sein
- Checkbox stellt booleschen Zustand dar (true/false)

package vl_java;
import javax.swing.*;
public class VL_05_Beispiel30_6 {
    public static void main(String[] args){
        JFrame j = new JFrame();
        j.setBounds(100, 100, 300, 200);
        JMenuBar menuBar = new JMenuBar();
        JMenu menu = new JMenu("Datei");
        JMenu sub = new JMenu("Speichern");
        menu.add(new JMenuItem("Neu"));
        menu.add(sub);
        menu.add(new JCheckBoxMenuItem("zentriert"));
        sub.add(new JMenuItem("..als HTML"));
        sub.add(new JMenuItem("..als Source"));
        menuBar.add(menu);
        j.setJMenuBar(menuBar);
        j.setVisible(true);
    }
}

- Menueinträge aktivieren/deaktivieren durch void setEnabled(boolean b)-Methode, von MenuItem-Klasse
- Grundsätzlich sind Menueinträge aktiviert

package vl_java;
import javax.swing.*;
public class VL_06_Beispiel30_6 {
    public static void main(String[] args){
        JFrame j = new JFrame();
        j.setBounds(100, 100, 300, 200);
        JMenuBar menuBar = new JMenuBar();
        JMenu menu = new JMenu("Datei");
        JMenu sub = new JMenu("Speichern");
        menu.add(new JMenuItem("Neu"));
        menu.add(sub);
        menu.add(new JCheckBoxMenuItem("zentriert"));
        sub.add(new JMenuItem("..als HTML"));
        sub.add(new JMenuItem("..als Source"));
        menuBar.add(menu);
        j.setJMenuBar(menuBar);
        j.setVisible(true);
        sub.setEnabled(false);
    }
}

Separatoren
- Menueinträge durch horizontale Linien trennen (Separatoren)
- Durch addSeparator() Befehl der Menu-Klasse

package vl_java;
import javax.swing.*;
public class VL_06_Beispiel30_6 {
    public static void main(String[] args){
        JFrame j = new JFrame();
        j.setBounds(100, 100, 300, 200);
        JMenuBar menuBar = new JMenuBar();
        JMenu menu = new JMenu("Datei");
        JMenu sub = new JMenu("Speichern");
        menu.add(new JMenuItem("Neu"));
        menu.add(sub);
        menu.addSeparator();
        menu.add(new JCheckBoxMenuItem("zentriert"));
        sub.add(new JMenuItem("..als HTML"));
        sub.add(new JMenuItem("..als Source"));
        menuBar.add(menu);
        j.setJMenuBar(menuBar);
        j.setVisible(true);
        sub.setEnabled(false);
    }
}

Shortcuts
- Auswahl von Menueintrag durch Shortcuts
- Durch Klasse KeyStroke implementiert
- Durch Methode setAccelerator dem Menu hinzugefügt

package vl_java;
import javax.swing.*;
import java.awt.event.*;
public class VL_06_Beispiel30_6 {
    public static void main(String[] args){
        JFrame j = new JFrame();
        j.setBounds(100, 100, 300, 200);
        JMenuBar menuBar = new JMenuBar();
        JMenu menu = new JMenu("Datei");
        JMenu sub = new JMenu("Speichern");
        menu.add(new JMenuItem("Neu"));
        menu.add(sub);
        JMenuItem zenItem = new JCheckBoxMenuItem("zentriert");
        zenItem.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_Z, KeyEvent.CTRL_DOWN_MASK));
        menu.add(zenItem);
        menu.addSeparator();
        sub.add(new JMenuItem("..als HTML"));
        sub.add(new JMenuItem("..als Source"));
        menuBar.add(menu);
        j.setJMenuBar(menuBar);
        j.setVisible(true);
        sub.setEnabled(false);
    }
}

Menuauswahl
Wie auf Auswahl der Menueinträge reagieren?
- Bei Auswahl dem JMenuItem ein ActionEvent schicken
- Dem MenuItem ein ActionListener hinterlegen, um auf ActionEvent zu reagieren (siehe auch: Drücken eines Buttons)

class JMenuItem{
    public void addActionListener(ActionListener l);
}
interface ActionListener{
    public void actionPerformed(ActionEvent e);
}
class ActionEvent{
    public String getActionCommand();
}

package vl_java;
import javax.swing.*;
import java.awt.*;
import java.awt.event.*;
public class VL_05_Beispiel31 {
    public static void main(String[] args){
        JFrame j = new JFrame();
        j.setBounds(100, 100, 300, 200);
        JMenuBar menuBar = new JMenuBar();
        JMenu menu = new JMenu("Datei");
        JMenuItem endeItem = new JMenuItem("Beenden");
        endeItem.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_E, KeyEvent.CTRL_DOWN_MASK));
        menu.add(endeItem);
        menuBar.add(menu);
        j.setJMenuBar(menuBar);
        j.setVisible(true);
        endeItem.addActionListener(e -> {
            System.out.println(e.getActionCommand());
            j.dispose();
        });
    }
}

Popup Menus
- Sind kontextabhängig: Bieten Aktionen, verfügbar nur in bestimmten Breichen des Programms
- Sind nicht permanent vorhanden, sondern nur auf Anforderung (Maustaste, spezielle Tastaturtasten, Kombination von beiden).
- Aufruf und Erscheinungsbild unterschiedlich von Betriebssystem und graphischen Oberflächen
- Abgeleitet von Klass Menu
- Implementiert durch Klasse JPopupMenu

class JPopupMenu extends JMenu{
    ...
    public void show(Component father, int x, int y);
    ...
}

- show()-Methode zeigt Menu auf Bildschirm
- verschwindet, sobald MenuItem oder was anderes selektiert wird.
- father ist Komponente, zudem das Popupmenu gehört
- x und y sind Koordinaten für das Erscheinen des Menus

Frage: Wann und wie show()-Methode aufrufen?
Lösung: Mausereignis anfangen und abfragen, ob "abstrakte" Ereignis zum Aufrufen des Popup eingetreten ist

class MouseEvent{
    ...
    public boolean isPupopTrigger();
    ...
}
________________________________________________________________________________________________________________________
    Vorlesung 7 - Dialoge
Zweck: Angaben von Benutzer annehmen, an Programm weiterleiten
Zwei Situationen:
1. Eigabe für Programm (damit es weiterarbeiten kann) nicht notwendig -> nicht-modale Dialoge
2. Eingabe notwendig (sonst kann Programm nicht weiterarbeiten) -> modale Dialoge

Erzeugen von Dialoge - Fünf Schritte:
1. Dialogfenster erzeugen
2. Dialogfenster Layout-Manager zuordnen
3. Diaglogfesnter Dialogelemente hinzufügen
4. Dialogfenster packen (pack-Methode)
5. Dialogfenster anzeigen (setVisible(true);)

Erzeugen von Dialogfenstern
- Dialogfenster von JDialog abgeleitet
- haben Titelleiste
- haben keine Menus
- können nicht maximiert, oder in Taskleiste gelegt werden
- können Programm blockieren (Möglichkeit modaler Dialoge)

Einfügen von Dialog-Elementen
- Einzelne Dialog-Elemente mittels add-Methode dem Dialog-Fenster logisch zuordnen

class Container{
    ...
    public Component add(Component comp);
    public Component add(Component comp, int pos);
    public Component add(String pos, Component comp);
    public void add(Component comp, Object Contraints);
    public void add(Component comp, Object Contrains, int pos);
    ...
}

- Logische Zuordnung sagt nichts über Darstellung aus.
- Alle Dialog-Elemente sequentiell hintereinander angeordnet.

Zuordnung eines Layout-Mangers
- Frage: Wie von sequentiellen Anordnung von Dialogelementen, zur graphischen Anordnung von Dialogelementen im Dialogfenster kommen?
- Antwort: Layout-Manager berechnet Zuordnungsmöglichkeiten von Dialogelementen zueinander. Dazu: logisches Layout angeben ("El a unterhalb von El b anordnen").
- Andere Graphiksysteme - Elemetne physikalisch anordnen: El a liegt 23 px unter El b, etc.

- Layout-Manager rechnet logische Zuordnung in physikalische Zuordnung um
    -> Logische Zuordnung --(Layout-Manager)--> Physikalische Zuordnung --(paint-Routine)--> Darstellung im Dialog
- Vorteil dieses Vorgehens:
    -> schafft neue, abstrakte Ebene
    -> ist flexibler, funktioniert auf unterschiedlichen Syst.
    -> Benutzer muss Dialog nicht zeichn. sondern entwerf.

- Klasse Container hat eine Methode:
    public void setLayout(LayoutManager mgr);
- Dient zur Festlegung des angegebenen Layout-Managers für Dialogelemente
- Es gibt 5+1 Layout-Manager in AWT
    1. FlowLayout
    2. GridLayout
    3. BorderLayout
    4. CardLayout       (nicht behandelt)
    5. GridBagLayout    (nicht behandelt)
    6. null

FlowLayout-Manager
- Einfachster Layout-Manager
- Alle Dialog-Elemene gemäß logischer Reihenfolge auch physikalisch sequentiell abgeelgt
- Wenn eine Reihe voll, dann darunetr eine neue Reihe geöffnet
- Es gibt drei Konstruktoren:
    -> public FlowLayout();
    -> public FlowLayout(int align);
    -> public FlowLayout(int align, int hgap, int vgap);
    - FlowLayout.LEFT/RIGHT/CENTER

Beispiel für FlowLayout-Manager

package vl_java;
import javax.swing.*;
import java.awt.*;
import java.awt.event.*;
public class VL_07_Beispiel34 extends JDialog{
    public VL_07_Beispiel34(JFrame f, String title, LayoutManager mgr){
        super(f, title);
        setLayout(mgr);
        add(new JButton("1"));
        add(new JButton("Ein seeeehhr großer Button"));
        add(new JButton("juhu"));
        pack();
        setVisible(true);
    }
    public static void main(String[] args){
        JFrame f = new JFrame();
        new VL_07_Beispiel34(f, "ganz einfach", new FlowLayout());
        new VL_07_Beispiel34(f, "rechtsbündig", new FlowLayout(FlowLayout.RIGHT));
        new VL_07_Beispiel34(f, "linksbündig und mehr Abstand", new FlowLayout(FlowLayout.LEFT, 20, 50));
    }
}

GridLayout-Manager
- In einem fest vorgegebenen Gitter (Tabelle)
- Alle Elemente gemäß der logischen Reihenfolge abgelegt in der Tabelle:
    -> Jede Zeile von links nach rechts vorgagengen
- Jede Tabellenzelle gleichgroß
- Anpassung der Elemente auf Zellengröße
- Falls Anzahl Zellen nicht genug, werden Zeilen verlängert => Anzahl Spalten vermehrt
- Zwei Konstruktoren:
    public GridLayout(int rows, int columns)
    public GridLayout(int rows, int columns, int hgap, int vgap);

package vl_java;
import javax.swing.*;
import java.awt.*;
public class VL_07_Beispiel35 extends JDialog{
    public VL_07_Beispiel35(JFrame f, String title, LayoutManager mgr){
        super(f, title);
        setLayout(mgr);
        add(new JButton("1"));
        add(new JButton("Ein seeeehhr großer Button"));
        add(new JButton("juhu"));
        setLocation(200, 200);
        pack();
        setVisible(true);
    }
    public static void main(String[] args){
        JFrame f = new JFrame();
        new VL_07_Beispiel35(f, "ganz einfach", new GridLayout(2, 2));
        new VL_07_Beispiel35(f, "mit mehr Abstand", new GridLayout(2, 2, 20, 50));
        new VL_07_Beispiel35(f, "zu klein", new GridLayout(1, 2, 20, 50));
    }
}


BorderLayout-Manager
- Kann bis fünf Dialogelemente anordnen
- Werden in vier Himmelsrichtungen, und in der Mitte platzeiert.
- Platzierung unabhängig von logischer Reihenfolge. Fokus hingegen abhängig von logischer Reihenfolge
- Ort wird angegeben durch add-Methode:
    public Componentm add(String pos, Component comp);
- Mögliche Position f pos
    BorderLayout.NORTH/SOUTH/EAST/WEST/CENTER
- Bei Angabe von falscher Positio => Exception
- Bei mehrere Elemente auf eine Position, wird das letzte angezeigt
- Zwei Konstruktoren:
    public Borderlayout();
    public BorderLayout(int hgap, int vgap);
    - hgap => horizontaler Platz in px
    - vgap => vertikaler Platz in px
    (oben) Freigelassener Platz zwischen Elementen
    Grundsätzlich kein Platz => hgap = vgap = 0;
- Veränderung Fenstergröße <= äquiavalent zu => Veränderung Größe v. Dialogelemente

package vl_java;
import javax.swing.*;
import java.awt.*;
public class VL_07_Beispiel36 extends JDialog{
    public VL_07_Beispiel36(JFrame f, String title, LayoutManager mgr){
        super(f, title);
        setLayout(mgr);
        add(BorderLayout.NORTH, new JButton("1"));
        add(BorderLayout.SOUTH, new JButton("Ein seeeeehr großer Button"));
        add(BorderLayout.WEST, new JButton("Wat is?"));
        add(BorderLayout.EAST, new JButton("juhu"));
        add(BorderLayout.CENTER, new JButton("Mitte"));
        pack();
        setVisible(true);
    }
    public static void main(String[] args){
        JFrame f = new JFrame();
        new VL_07_Beispiel36(f,"ganz einfach", new BorderLayout());
        new VL_07_Beispiel36(f, "mit mehr Abstand", new BorderLayout(20, 50));
    }
}
________________________________________________________________________________________________________________________
    Vorlesung 8 - Schachteln von Layout-Manager

- Klasse JPanel - einfachste konkrete Fensterklasse
    -> Nimmt Dialogelemente auf, ordnet sie mittels eines Layout-Managers innerhalb ihrer Grenzen
    -> Kann einem übergeordneterem Layout-Manager übergeben werden
    -> Zerlegung in logische Unterstrukturen (Tabellen, darin wiederum Tabellen, etc.)

package vl_java;
import javax.swing.*;
import java.awt.*;
public class VL_08_Beispiel39 extends JDialog{
    public VL_08_Beispiel39(Frame f){
        super(f);
        setLayout(new GridLayout(2, 1));
        JPanel p1 = new JPanel();
        JPanel p2 = new JPanel();
        p1.setLayout(new GridLayout(1, 2));
        p2.setLayout(new GridLayout(2, 1));
        p1.add(new JButton("Otto"));
        p1.add(new JButton("Cancel or not Cancel"));
        add(new JButton("OK"));
        pack();
        setVisible(true);
    }
    public static void main(String[] args){
        new VL_08_Beispiel39(new JFrame());
    }
}

Der null-Layout-Manager
- kein Layout-Manager
- Keine Dialogelemente angeordnet
- Setzen von Größe und Position => Dem Fenster physikalisch angeordnet
- Es feht: Abstrakte Schicht des Layouts
- Nicht verwenden => Nicht portabel

package vl_java;
import javax.swing.*;
public class VL_08_Beispiel40 extends JDialog{
    public VL_08_Beispiel40(JFrame f){
        super(f);
        setSize(400, 300);
        setLayout(null);
        for(int i = 0; i < 5; ++i){
            JButton b = new JButton(Integer.toString(i));
            b.setBounds(50 + 35 * i, 30 + 30 * i, 50, 25);
            add(b);
        }
        setVisible(true);
    }
    public static void main(String[] args) throws Exception{
        new VL_08_Beispiel40(new JFrame());
    }
}

Einige Methoden der JDialog Klasse
- Dialog haben Titelzeile wir Frame-Fenster
    public void setTitle(String title);
- Modale Dialoge blocken Vaterfenster, solange Dialog sichtbar ist
- Im Konstruktor, oder durch Methodenaufruf, Modal-Flag setzen
    public void setModal(boolean modal);
- Zustand abfragen
    public boolean isModal();
- Entscheidung über Veränderbarkeit von Dialogfenster-Größe. Methode verfügbar auch für Frames
    public void setResizable(boolean resizable);
- Abfrage zur Veränderbarkeit von Fenster/Dialoggröße durch
    public boolean isResizable();

package vl_java;
import javax.swing.*;
import java.awt.event.*;
import java.awt.*;
class YesNoDialog extends JDialog{
    public boolean m_bResult;
    public YesNoDialog(JFrame owner, String msg){
        super(owner, "", true); setBackground(Color.lightGray);
        setLayout(new BorderLayout()); setResizable(false);
        Point p = owner.getLocation(); setLocation(p.x+30, p.y+30);
        add(BorderLayout.CENTER, new JLabel(msg));
        JPanel buttonPanel = new JPanel();
        buttonPanel.setLayout(new FlowLayout(FlowLayout.CENTER));
        add(BorderLayout.SOUTH, buttonPanel); JButton b = new JButton("Yes");
        b.addActionListener(e -> {
            m_bResult = true;
            dispose();
        });
        buttonPanel.add(b); b = new JButton("No");
        b.addActionListener(e -> {
            m_bResult = false;
            dispose();
        });
        buttonPanel.add(b); pack(); setVisible(true);
    }
}
public class VL_08_Beispiel41 extends JFrame{
    public VL_08_Beispiel41(){
        setSize(400, 300);
        setDefaultCloseOperation(DO_NOTHING_ON_CLOSE);
        addWindowListener(new WindowAdapter(){
            @Override
            public void windowClosing(WindowEvent e){
                YesNoDialog dgl = new YesNoDialog(VL_08_Beispiel41.this, "Soll das Programm beendet werden?");
                if(dgl.m_bResult)
                    dispose();
            }
        });
        setVisible(true);
    }
    public static void main(String[] args) throws Exception{
        new VL_08_Beispiel41();
    }
}

Die JFileChooser Klasse
- JFileChooser: Für Auswahl von Dateien
- Bietet eine Filterfunktionalität an:

class JFileChooser{
    public JFileChooser();
    public JFileChooser(File currentDir);
...
    int showOpenDialog(Component father);
    int showSaveDialog(Component father);
...
    void addChoosableFileFilter(FileFilter filter);
    File getSelectedFile();
}

- FileFilter: Abstrakte Klasse, von der die Impelementierung FileNameExtensionFilter existiert

class FileNameExtensionFilter extends FileFilter{
    public FileNameExtensionFilter(Strint description, String extensions);
    ...
}

package vl_java;
import javax.swing.*;
import javax.swing.filechooser.FileNameExtensionFilter;
import java.io.File;
public class VL_08_Beispiel78 {
    public static void main(String[] args){
        JFrame f = new JFrame();
        f.setSize(200, 200);
        f.setVisible(true);

        JFileChooser chooser = new JFileChooser(new File("."));
        chooser.addChoosableFileFilter(new FileNameExtensionFilter("JPG & GIF Images", "jpg", "gif"));
        chooser.addChoosableFileFilter(new FileNameExtensionFilter("Docs", "doc", "docx"));

        if(chooser.showOpenDialog(f) == JFileChooser.APPROVE_OPTION)
            System.out.println("ausgewählte Datei: " + chooser.getSelectedFile());
        if(chooser.showSaveDialog(f) == JFileChooser.APPROVE_OPTION)
            System.out.println("ausgewählte Datei: " + chooser.getSelectedFile());
    }
}

Die JOptionPane Klasse
- Enthält viele statische Methoden, zur Erzeugung von Standarddialogen
- Anzeigen einer Nachricht:

class JOptionPane{
    public static void showMessageDialog(Component parent, Object msg);
    public static void showMessageDialog(COmponent parent, Object msg, String title, int messageType);

    static final int ERROR_MESSAGE;
    static final int INFORMATION_MESSAGE;
    static final int WARMING_MESSAGE;
    static final int QUESTION_MESSAGE;
    static final int PLAIN_MESSAGE;
    ...
}

package vl_java;
import javax.swing.*;
import java.awt.*;
class Box extends JComponent{
    Box(){
        setPreferredSize(new Dimension(100, 100));
    }
    @Override
    public void paintComponent(Graphics g){
        g.drawRect(0, 0, getWidth() - 1, getHeight() - 1);
    }
}
public class VL_08_Beispiel65 {
    public static void main(String[] args) throws Exception{
        JFrame f = new JFrame("ich mache nix");
        f.setBounds(100, 100, 400, 300);
        f.setVisible(true);
        JOptionPane.showMessageDialog(f, "juhu");
        JOptionPane.showMessageDialog(f, "error", "Jetzt kommt der Titel: Dr.", JOptionPane.ERROR_MESSAGE);
        JOptionPane.showMessageDialog(f, "INFO", "Jetzt kommt der Titel: Dr.", JOptionPane.INFORMATION_MESSAGE);
        JOptionPane.showMessageDialog(f, new Box(), "Auch 'n Titel: von und zu", JOptionPane.WARNING_MESSAGE);
        JOptionPane.showMessageDialog(f, "Frage?", "Nix Title", JOptionPane.QUESTION_MESSAGE);
        JOptionPane.showMessageDialog(f, "langweilig", "Hier ist nix", JOptionPane.PLAIN_MESSAGE);
    }
}

Weitere Standarddialoge von JOptionPane Klasse, um Bestätigungsdialoge anzuzeigen: Alle Modal

class JOptionPane{
    public static int showConfirmDialog(Component parent, Object msg);
    public static int showConfirmDialog(Component parent, Object msg, String title, int optionType);
    public static int showConfirmDialog(Component parent, Object msg, String title, int optionType, int messageType);

    static final int YES_NO_OPTION;
    static final int OK_CANCEL_OPTION;
    static final int YES_NO_CANCEL_OPTION;
    ...
    static final int YES_OPTION;
    static final int NO_OPTION;
    static final int CANCEL_OPTION;
    static final int OK_OPTION;     // Das gleiche wie YES_OPTION
    static final int CLOSED_OPTION;
}

package vl_java;
import javax.swing.*;
public class VL_08_Beispiel66 {
    public static void pr(int msg){
        System.out.print("");
        switch(msg){
            case JOptionPane.YES_OPTION: System.out.println("yes"); break;
            // statt YES_OPTION auch OK_OPTION
            case JOptionPane.NO_OPTION: System.out.println("no"); break;
            case JOptionPane.CANCEL_OPTION: System.out.println("cancel"); break;
            case JOptionPane.CLOSED_OPTION: System.out.println("closed"); break;
        }
    }
    public static void main(String[] args){
        JFrame f = new JFrame("ich mache nix");
        f.setBounds(100, 100, 400, 300);
        f.setVisible(true);
        pr(JOptionPane.showConfirmDialog(f, "juhu"));
        pr(JOptionPane.showConfirmDialog(f, "ja oder nein", "", JOptionPane.YES_NO_OPTION));
        pr(JOptionPane.showConfirmDialog(f, new Box(), "nix", JOptionPane.OK_CANCEL_OPTION));
        pr(JOptionPane.showConfirmDialog(f, "Frage?", "Nix Title", JOptionPane.YES_NO_CANCEL_OPTION, JOptionPane.WARNING_MESSAGE));
    }
}

- Mit Standarddialogen der JOptionPane Klasse, einfache Daten eingeben

class JOptionPane{
    public static String showInputDialog(Component parent, Object msg);
    public static String showInputDialog(Component parent, Object msg, String title, int messageType);
    public static Object showInputDialog(Component parent, Object msg, String title, int messageType, Icon icon, Object[] selectionValues, Object initialSelectionValue);
    ...
}

package vl_java;
import java.awt.*;
import java.awt.event.*;
import javax.swing.*;
public class VL_07_Beispiel67 {
    public static String[] objs = {"juhu", "doll", "ich fass es nicht"};
    public static void main(String[] args) throws Exception{
        JFrame f = new JFrame("ich mache nix");
        f.setBounds(100, 100, 400, 300);
        f.setVisible(true);
        System.out.println(JOptionPane.showInputDialog(f, "juhu"));
        System.out.println(JOptionPane.showInputDialog(f, new Box(), "", JOptionPane.WARNING_MESSAGE));
        System.out.println(JOptionPane.showInputDialog(f, new Box(), "", JOptionPane.PLAIN_MESSAGE, null, objs, objs[2]));
    }
}
________________________________________________________________________________________________________________________
    Vorlesung 9 - Einfache Dialogelemente in Swing
JLabel
- Für Beschriftung von Dialogboxen
class JLabel{
    public JLabel();
    public JLabel(String text);
    public JLabel(String text, int align);
    public void setText(String text);
    public String getText();
    public void setHorizontalAlignment(int align);
    ...
}

package vl_java;
import javax.swing.*;
import java.awt.event.*;
import java.awt.*;
public class VL_09_Beispiel42 extends JDialog{
    public VL_09_Beispiel42(){
        super(new JFrame());
        setLayout(new GridLayout(4, 1));
        add(new JLabel("Default"));
        final JLabel l = new JLabel("Links", SwingConstants.LEFT);
        add(l);
        l.addMouseListener(new MouseAdapter(){
            @Override
            public void mouseEntered(MouseEvent e){
                l.setText("RECHTS");
                l.setHorizontalAlignment(SwingConstants.RIGHT);
            }
            @Override
            public void mouseExited(MouseEvent e){
                l.setText("Links");
                l.setHorizontalAlignment(SwingConstants.LEFT);
            }
        });
        add(new JLabel("Rechts", SwingConstants.RIGHT));
        add(new JLabel("In der Mitte", SwingConstants.CENTER));
        pack();
        setVisible(true);
    }
    public static void main(String[] args) throws Exception{
        new VL_09_Beispiel42();
    }
}

Die JPasswordField KLasse
- Spezialisierung der JTextField Klasse
- Die für Passwort-Eingabe
- Eingegeber Text wird nicht angezeigt, sondern durch Sonderzeichen ersetzt
- Dieses Zeichen veränderbar, durch setEchoChar
- Eingegebener Text abfragen durch: getPassword
- Copy- und Cut-Methoden ausgeschaltet
- return-Taste löst ActionEvent aus
class JPasswordField extends JTextField{
    public void setEchoChar(char);
    public char[] getPassword();
    ...
}

package vl_java;
import java.awt.*;
import java.awt.event.*;
import javax.swing.*;
public class VL_09_Beispiel69 extends JFrame{
    public VL_09_Beispiel69(){
        final JPasswordField field = new JPasswordField();
        field.addActionListener(e -> System.out.println(field.getPassword()));
        add(field);
        pack();
        setVisible(true);
    }
    public static void main(String[] args){
        new VL_09_Beispiel69();
    }
}

Die JFormattedTextField Klasse
- von JTextField abgeleitet
- Zur Eingabe und Darstellung von formatierten Text
- Während Eingabe wird geprüft: Spricht der eingegebene Text der Formatierung?
- Sinnvoll für Eingabemasken:
    -> Eingabe von Zahlen -> Buchstaben unzulässig
    -> Eingabe von Buchstaben -> Zahlen unzulässig
    -> Eingabe von Datum/IP-Adresse -> Zahlen in einem bestimmten Format zulässig

class JFormattedTextField extends JTextField{
    public JFormattedTextField();
    public JFormattedTextField(JFormattedTextField.AbstractFormatter);
    ...
}

package vl_java;
import java.awt.*;
import java.awt.event.*;
import javax.swing.*;
public class VL_09_Beispiel69_2 extends JFrame{
    public VL_09_Beispiel69_2(){
        final JFormattedTextField text = new JFormattedTextField();
        add(text);
        text.addActionListener(e -> System.out.println(text.getText()));
        pack();
        setVisible(true);
    }
    public static void main(String[] args){
        new VL_09_Beispiel69_2();
    }
}

- Format über den Parameter eingeben: JFormattedTextField.AbstractFormatter
- Klasse MaskFormatter -> Mögliche Implementierung der abstrakten Klasse AbstractFormatter
- String im Konstruktor, um Maskte zu beschreiben
- String "juhu" lässt Wort "juhu" zu

class MaskFormatter extends AbstractFormatter{
    public MaskFormatter(String) throws ParseError;
}

- Folgende Sonderwerte in String erlaubt:
# -> Beliebige Ziffer 0, 1, ..., 9
' -> Escape Zeichen zur Darstellung dieser Metazeichen
U -> Beliebiger Buchstabe -> Alles Groß
L -> Beliebiger Buchstabe -> Alles klein
A -> Buchstabe oder Ziffer
? -> Irgendein Zeichen
* -> Irgend etwas
H -> Hexadezimalzeichen

- Beispiel: new MaskFormatter("##-##-###");
    -> Mögliche Eingabe: 23-45-2334
- "Leerstellen" können angezeigt werden, sowie gesetzt werden, durch Methode:
    setPlaceholderCharacter(char placeholder)
- Einzugebende Buchstaben weiter einschränken
    setValidCharacter(String)
  -> Beispiel:
  MaskFormatter mask = new MaskFormatter("##-UU-####'U");   // mögliche Eingabe
  mask.setPlaceholderCharacter('_');
  mask.setValidCharacters("ABC123");

Die Document Klasse
- Problem mit MaskFormatter: Format legt feste Anzahl von Eingabezeichen vor
- oft zu restriktiv
- Soll z.B. Eingabe geprüft werden, -24536 oder -67
    Kann MaskFormatter nicht verwendet werden, da Zahl eine beliebige Länge hat
- Man kann ein Document Object mittels setDocument() registrieren, im JTextField (und im JFormattedTextField)
- Document Klasse ist abstract
- Mögliche konkrete Implementierung durch Klasse PlainDocument
- Sobald Text in JTextField eingetragen, dann wird aufgerufen
    void insertString(int offs, String str, AttributeSet a)
- Durch Überlagern dieser Methode, wird kontrolliert, was in Textfield eingetragen wird

package vl_java;
import javax.swing.*;
import javax.swing.text.*;
import java.awt.*;
import java.awt.event.*;
class VL_09_Beispiel69_6_MyDocument extends PlainDocument {
    public void insertString(int offs, String str, AttributeSet a) throws BadLocationException{
        try{
            Integer.parseInt(str);
        } catch(Exception ex){
            Toolkit.getDefaultToolkit().beep();
        }
    }
}
public class VL_09_Beispiel69_6 extends JFrame{
    public VL_09_Beispiel69_6(){
        final JTextField text = new JTextField();
        text.setDocument(new VL_09_Beispiel69_6_MyDocument());
        add(text);
        text.addActionListener(e -> System.out.println(text.getText()));
        pack();
        setVisible(true);
    }
    public static void main(String[] args){
        new VL_09_Beispiel69_6();
    }
}

Die JSlider Klasse
- analog zu JScrollbar -> ein Dialogelement zur analogen Eingabe
- hat eine Anzeigeskala mit grober und feiner Einteilung
- hat keine unterschiedliche Schiebegröße, sondern eine Ausdehnung von 1.

class JSlider{
    public JSlider(int orientation, int min, int max, int value);
    public int getValue();
    public in getMinimum();
    public int getMaximum();
    final static int VERTICAL;
    final static int HORIZONTAL;
    ...
}

- Breite der groben Einteilung einstellen
    setMajorTickSpacing()
- Breite für feine Einteilung einstellen
    setMinorTickSpacing
- Um Ticks und Labels sichtbar machen, durch Methoden... auf Bildschirm bringen
    -> setPaintTicks()
    -> setPaintLabels()

class JSlider{
    ...
    public void setMajorTickSpacing(int n);
    public void setMinorTickSpacing(int n);
    public void setPaintTicks(boolean b);
    public void setPaintLabels(boolean b);
}

- Slider nur noch bei Ticks einrasten
    setSnapToTicks(true)
- Im Gegensatz zu Scrollbar -> Bei Veränderung kein AdjustmentEvent, sondern ein ChangeEvent

class JSlider{
    ...
    public void setSnapToTicks(boolean b);
    public void addChangeListener(ChangeListener ch);
}
interface ChangeListener{
    public void stateChanged(ChangeEvent e);
}

- JSlider bietet zwei Möglichkeiten zum Abruf vom internen Wertezustand
- getValue liefert aktuell eingestellten Wert. Während Einstellens wird ständig aktueller Wert zurückgeliefert
- Methode getValueIsAdjusting liefert Wert false zurück wenn Änderung abgeschlossen, sonst true

class JSlider{
    ...
    public int getValue();
    public boolean getValueIsAdjusting();
}

package vl_java;
import javax.swing.*;
import java.awt.*;
import javax.swing.event.*;
interface VL_09_Beispiel70_Doit{
    public void doit(boolean b);
}
class VL_09_Beispiel70_MyButton extends JButton{
    boolean m_bVal;
    String m_Label;
    public VL_09_Beispiel70_MyButton(String label, VL_09_Beispiel70_Doit fct){
        super("set " + label);
        m_Label= label;
        m_bVal = true;
        addActionListener(e -> {
            fct.doit(m_bVal);
            setText((m_bVal ? "remove " : "set ") + m_Label);
            m_bVal = !m_bVal;
        });
    }
}

public class VL_09_Beispiel70 extends JFrame{
    public VL_09_Beispiel70(){
        final JSlider SLIDER = new JSlider(JSlider.VERTICAL, 10, 100, 15);
        SLIDER.setMajorTickSpacing(25);
        SLIDER.setMinorTickSpacing(5);
        setLayout(new GridLayout(2, 2));
        add(SLIDER);
        add(new VL_09_Beispiel70_MyButton("ticks", b -> SLIDER.setPaintTicks(b)));
        add(new VL_09_Beispiel70_MyButton("label", b -> SLIDER.setPaintLabels(b)));
        add(new VL_09_Beispiel70_MyButton("snap2ticks", b -> SLIDER.setSnapToTicks(b)));

        SLIDER.addChangeListener(e -> {
            System.out.println(SLIDER.getValue());
            if(!SLIDER.getValueIsAdjusting())
                System.out.println("... that's it");
        });
        pack();
        setVisible(true);
    }
    public static void main(String[] args){
        new VL_09_Beispiel70();
    }
}

JSpinner Klasse
- Zur Auswahl aus einer Liste (wie zu einer Choice)
- Änderung löst: ChangeEvent
- Liefet selektiertes Objekt vom Typ Object: getValue()
- Grundsätzlich Integer Objekte zurückgeliefert (aber als Typ Object)

JFrame frame = new JFrame("JSpinner");
final JSpinner spin = new JSpinner();
spin.addChangeListener(e -> System.out.println(spin.getValue()));
frame.add(spin);
frame.pack();
frame.setVisible(true);

- Dem Konstruktor kann das SpinnerModel Interface Implementierung übergeben werden
- SpinnerModel koordiniert, potenzielle Objekte zur Selektion
- SpinnerListModel: Implementierung, die Objekt-Arrays an JSpinner übergibt

package vl_java;
import java.awt.*;
import java.awt.event.*;
import javax.swing.*;
import javax.swing.event.*;
class VL_09_Beispiel80_MyColor{
    private String mName;
    Color mColor;
    VL_09_Beispiel80_MyColor(String name, Color col){
        mName = name; mColor = col;
    }
    public String toString(){
        return mName;
    }
}
public class VL_09_Beispiel80 {
    public static void main(String[] args) throws Exception{
        VL_09_Beispiel80_MyColor[] cols = {new VL_09_Beispiel80_MyColor("rot", Color.RED),
                                           new VL_09_Beispiel80_MyColor("grün", Color.GREEN),
                                           new VL_09_Beispiel80_MyColor("blau", Color.BLUE)};
        SpinnerListModel model = new SpinnerListModel(cols);
        JFrame frame = new JFrame("JSpinner");
        final JSpinner spin = new JSpinner(model);
        final JComponent c = new JComponent(){
            public void paintComponent(Graphics g){
                g.drawLine(0, 0, getWidth(), getHeight());
            }
        };
        spin.addChangeListener(e -> {
            VL_09_Beispiel80_MyColor col = (VL_09_Beispiel80_MyColor)spin.getValue();
            c.setForeground(col.mColor);
            c.repaint();
        });
        frame.setLayout(new GridLayout(2, 1));
        frame.add(spin);
        frame.add(c);
        frame.pack();
        frame.setVisible(true);
    }
}

- Ähnlicher Effekt mit JComboBox

package vl_java;

import java.awt.*;
import java.awt.event.*;
import javax.swing.*;
import javax.swing.event.*;

class VL_09_Beispiel80_1_MyColor{
    private String mName;
    Color mColor;
    VL_09_Beispiel80_1_MyColor(String name, Color col){
        mName = name; mColor = col;
    }
    public String toString(){
        return mName;
    }
}
public class VL_09_Beispiel80_1 {
    public static void main(String[] args) throws Exception{
        VL_09_Beispiel80_1_MyColor[] cols = {new VL_09_Beispiel80_1_MyColor("rot", Color.RED),
                new VL_09_Beispiel80_1_MyColor("grün", Color.GREEN),
                new VL_09_Beispiel80_1_MyColor("blau", Color.BLUE)};
        JFrame frame = new JFrame("JComboBox");
        final JComboBox<VL_09_Beispiel80_1_MyColor> spin = new JComboBox<VL_09_Beispiel80_1_MyColor>(cols);
        final JComponent c = new JComponent(){
            public void paintComponent(Graphics g){
                g.drawLine(0, 0, getWidth(), getHeight());
            }
        };
        spin.addActionListener(e -> {
            VL_09_Beispiel80_1_MyColor col = (VL_09_Beispiel80_1_MyColor)spin.getSelectedItem();
            c.setForeground(col.mColor);
            c.repaint();
        });
        frame.setLayout(new GridLayout(2, 1));
        frame.add(spin);
        frame.add(c);
        frame.pack();
        frame.setVisible(true);
    }
}

Die JProgressBar Klasse
- Zur Anzeige eines Fortschritts
- Wird in Prozent gezeigt

class JProgressBar{
    public JProgessBar();
    public JProgessBar(int orient);
    public JProgessBar(int min, int max);
    public JProgessBar(int orient, int min, int max);

    public int getValue();
    public int getMinimum();
    public int getMaximum();
    public void setValue(int);

    final static int VERTICAL;
    final static int HORIZONTAL;
    ...
}

- Entscheiden, ob Anzeige auch textuell sein soll:

class JProgessBar{
    ...
    public void setStringPainted(boolean b);
    ...
}

package vl_java;

import javax.swing.*;
import java.awt.*;

public class VL_09_Beispiel71 extends JFrame{
    public VL_09_Beispiel71(){
        final JProgressBar progress = new JProgressBar(JProgressBar.VERTICAL, 10, 300);
        progress.setStringPainted(true);
        setLayout(new FlowLayout());
        JButton next = new JButton("more");
        add(progress);
        add(next);
        next.addActionListener(e -> {
            progress.setValue((progress.getValue() + 5) % progress.getMaximum());
        });
        pack();
        setVisible(true);
    }
    public static void main(String[] args){
        new VL_09_Beispiel71();
    }
}
________________________________________________________________________________________________________________________
    Vorlesung 10 - Bitmaps

Bitmaps: in zwei Schritten auf Bildschirm bringen
1. Bild vom Rechner oder aus Netz laden (oder selber erstellen)
2. Bild im Graphikkontext malen - durch versch. drawImage Methoden von Graphics
- Bilder durch Klasse Image implementieren

Laden von Bitmaps
- Mehrere Methoden durch Klasse Toolkit
class Toolkit{
    ...
    public abstract Image getImage(String filename);
    public abstract Image getImage(URL url);
    public abstract Image createImage(String filename);
    public abstract Image createImage(URL url);
}

- Bitmaps vom Rechner laden:
    -> getImage(String filename);
    -> createImage(String filename);
- Bitmaps laden über Netz:
    -> getImage(URL url);
    -> createImage(URL url);

- getImage speichert Bitmaps zwischen
    Image i1 = getToolkit().getImage("juhu");
    ...
    Image i2 = getToolkit().getImage("juhu");

    - i1 und i2 werden dasselbe Bild enthalten
    - beim 2. Aufruf wird geschaut, ob Bild zuvor geladen wurde
    - wenn ja, wird das verwendet
    - zwisch.zeitl. Änderungen auf Bild, vom Prog. nicht wahrgen.

- createImage - Bitmaps bei jedem Aufruf neu geladen
    Image i1 = getToolkit().createImage("juhu");
    Image i2 = getToolkit().createImage("juhu");

    - i1 undd i2 haben nicht dasselbe Bild
    - beim 2. Aufruf, Bild neu aus Dateisystem geladen
    - zwisch.zeitl. Änderungen auf Bild, vom Prog, wahrgen.

package vl_java;
import javax.swing.*;
import java.awt.*;
import java.awt.event.*;
interface Loader{   // Ein Interface, um die Klasse Beispiel54 unabhängig von der Lademethode zu machen
    public Image load();
}
public class VL_10_Beispiel54 extends JFrame{
    Image img1, img2;
    public VL_10_Beispiel54(final Loader l, String title){
        super(title);
        setBounds(100, 100, 200, 200);
        img1 = l.load();    // Das 1. Bild wird sofort geladen
        addKeyListener(new KeyAdapter(){    // Das 2. Bild wird erst nach einem Tastendruck geladen
            public void keyPressed(KeyEvent e){
                img2 = l.load();
                repaint();
            }
        });
       add(new JComponent(){
           @Override
           public void paintComponent(Graphics g){
               g.drawImage(img1, 0, 0, this);
               if(img2 != null)
                   g.drawImage(img2, img1.getWidth(this), img1.getHeight(this), this);
           }
       });
       setVisible(true);
    }
    public static void main(String[] args){
        Toolkit t = Toolkit.getDefaultToolkit();
        new VL_10_Beispiel54(() -> t.getImage("src/vl_java/ZZ5H.gif"), "mit getImage");
        new VL_10_Beispiel54(() -> t.createImage("src/vl_java/ZZ5H.gif"), "mit createImage");
    }
}

Laden von Bitmaps: ein genauer Blick
- Methode zum Laden blocken Programm nicht
- Sie starten das Laden und geben Programmkontrolle sofort zurück
- Greift man dann sofort auf Bild zu, ist es noch nicht ganz geladen
- Will man bis Laden warten, hilft Klasse MediaTracker

MediaTracker
class MediaTracker{
    public MediaTracker(Component client);
    public void addImage(Image image, int id);
    public boolean checkAll();
    public void waitForAll() throws InterruptedException;
    ...
}

- addImage() fügt image unter dem Namen mit id, dem MediaTracker hinzu
- checkAll() sagt: sind alle Bilder geladen oder nicht - (true)/(false)
- waitForAll wartet solange, bis alle Bilder geladen

package vl_java;

import javax.swing.*;
import java.awt.*;

public class VL_10_Beispiel56 extends JFrame {
    Image img;

    public VL_10_Beispiel56(boolean bWait) throws Exception {
        super(bWait ? "mit warten" : "ohne warten");
        img = getToolkit().createImage("src/vl_java/feder.jpg");
        if (bWait) {  // bWait kontrolliert, ob zu warten, bis Bild geladen
            MediaTracker mt = new MediaTracker(this);
            mt.addImage(img, 1);
            mt.waitForAll();
        }
        add(new JComponent() {
            public void paintComponent(Graphics g) {
                g.drawImage(img, 0, 0, getWidth(), getHeight(), this);
            }
        });
        setBounds(50, 50, img.getWidth(this), img.getHeight(this)); // Zugriff auf Bilddaten
        setVisible(true);
    }

    public static void main(String[] args) throws Exception {
        new VL_10_Beispiel56(true);
        new VL_10_Beispiel56(true);
    }
}

Animation
- Unter Animation wird verstanden: Darstellung bewegter Bilder
- Wird erreicht durch: schnelle aufeinanderfolgende Darstellung einzelner Bilder
- Sequentielle Folge wird von Mensch als Bewegung wahrgenommen, wenn Änderung von Bild zu Bild gering ist
- Frage: Wird Kotrolle versch. Bilder in paintComponent-Routine eingebaut?
- Antwort: NEIN

- Problem - Falls Kontrolle in paintComponent-Routine eingebaut wird:
    -> Anwendung kann nicht mehr auf Benutzer-Events reagieren
    -> Animation fängt immer wieder von vorne an, sobald paintComponent-Routine aufgerufen wird

- Lösung - Kontrolle in eine andere Routine einbauen:
    -> diese ruft dann repaint-Methode auf
    -> repaint ist eine Methode aus JComponent
    -> repaint-Methode ruft paintComponent-Routine auf
package vl_java;

import javax.swing.*;
import java.awt.*;
import java.awt.event.*;

public class VL_10_Beispiel57 extends JFrame {
    Image m_Img;
    int m_iHeight = 0;
    int m_iSleeper;
    volatile int m_iMaxHeight = 0; // volatile => WICHTIG !!!

    public VL_10_Beispiel57(int iSleeper) throws Exception {
        m_iSleeper = iSleeper;
        m_Img = getToolkit().createImage("src/vl_java/feder.jpg");
        MediaTracker mt = new MediaTracker(this);   //  *
        mt.addImage(m_Img, 1);  // *
        mt.waitForAll();    // * Lädt ein Bild ein und wartet den Vorgang ab
        setBounds(50, 50, m_Img.getWidth(this) * 2, m_Img.getHeight(this) * 10);
        addComponentListener(new ComponentAdapter() {    // Ändert sich die Größe des Fensters, wird die Maximalhöhe zurückgesetzt
            public void componentResized(ComponentEvent e) {
                m_iMaxHeight = 0;
            }
        });
        add(new JComponent() {
            @Override
            public void paintComponent(Graphics g) {
                if (m_iMaxHeight == 0)
                    m_iMaxHeight = getHeight() - m_Img.getHeight(this);
                g.drawImage(m_Img, 0, m_iHeight, this);
                g.drawImage(m_Img, m_Img.getWidth(this), m_iMaxHeight - m_iHeight, this);
            }
        });
        getContentPane().setBackground(Color.white);
        setVisible(true);
    }

    public void anime() throws Exception {
        while (true) {
            for (m_iHeight = m_iMaxHeight; m_iHeight > 0; m_iHeight -= 1) {   // m_iHeight kontrolliert die Sprunghöhe
                Thread.sleep(m_iSleeper);
                repaint();  // *
            }
            for (m_iHeight = 0; m_iHeight < m_iMaxHeight; m_iHeight += 1) {
                Thread.sleep(m_iSleeper);
                repaint();  // * Nachdem eine neue Sprunghöhe berechnet worden ist, wird das Fenster neu gezeichnet
            }
        }
    }

    public static void main(String[] args) throws Exception {
        VL_10_Beispiel57 b = new VL_10_Beispiel57(2);
        b.anime();
    }
}

Nebenläufigkeit
- Aufgabe: zwei Fenster öffnen, in denen die Bälle auf- und abspringen
- Lösungsansatz: zwei Objekte von Klasse Beispiel57 erstellen, und anime() anfrufen
import java.awt.*;
class Beispiel57_5 extends JFrame{
    public static void main(String[] args) throws Exception{
        Beispiel57 b1 = new Beispiel57(2);
        Beispiel57 b2 = new Beispiel57(2);
        b1.anime();
        b2.anime();
    }
}
- Frage: Was wird passieren?
- Problem:
    -> anime() hat Endlosschleife: Programm kommt davon nicht mehr raus
    -> Somit wird zweiter Aufruf, also b2.nime() nie ausgeführt
    -> Programmablauf kann sich nicht teilen, um zwei Dinge gleichzeitig zu tun
- Lösung:
    -> Programmablauf "teilen", um mehrere Sachen gleichzeitig zu tun.

- "normaler", sprich sequentieller Programmablauf:
    -> alle Schritte hintereinander
    -> neuer Schritt fängt an, wenn alter Schritt beendet
    -> alle Schritte können durchgezählt werden

- "geteilter", sprich paralleler Programmablauf:
    -> nach einem Schritt: Programm kann sich aufteilen, läuft nebeneinander her
    -> in einem Faden ("Thread"): ein Schritt kommt nach dem anderen
        (sequentiell, d.h. 2a < 3a)
    -> Schritte der Fäden zueinander - unbekannt:
        (3a < 3b oder 3a > 3b ist
    -> ein Faden kann sich wieder aufteilen

- Klasse Thread erzeugt in Java solche neue Pfäden:
    -> Methoe start von Thread teilt Programm auf
    -> Erster Faden macht nach start weiter (Faden: 3a)
    -> Zweiter Faden macht im run weiter (Faden: 3b)

  ____________________________________
  class Thread ... {
    public void run() {...(Faden: 3b)}
  }
  ...

  Thread t = new Thread(); (Faden: 1)
  t.start();    (Faden: 2)
  System.out.println(...);  (Faden: 3a)
  ____________________________________
  class Juhu ... {
    public void start() { ... (Faden: 3)}
  }
  ...

  Juhu t = new Juhu();  (Faden: 1)
  t.start();    (Faden: 2)
  System.out.println(...);  (Faden: 4)
  ____________________________________

  class Thread ... {
    public void start();
    public void run();
    ...
  }

- Vorgehensweise für Nebenläufigkeit
    1. eigene Klasse von Thread ableiten
    2. Methode run() überschreiben
    3. Objekt von abgeleiteter Thread-Klasse erzeugen
    4. Davon start() aufrufen
    => es wird nach start() und in run() weitergearbeitet
package vl_java;

public class VL_10_Beispiel58 extends Thread {
    String m_Msg;

    public VL_10_Beispiel58(String msg) {
        m_Msg = msg;
    }

    public void run() {
        while (true) {    // Endlosschleife
            System.out.println(m_Msg);
            try {
                Thread.sleep((int) (Math.random() * 1500));  // schläft zufällig bis zu 1,5 Sekunden
            } catch (InterruptedException e) {
            }
        }
    }

    public static void main(String[] args) throws Exception {
        VL_10_Beispiel58 b1 = new VL_10_Beispiel58("Hello World");
        VL_10_Beispiel58 b2 = new VL_10_Beispiel58("cool...");
        b1.start(); // 1. Thread erzeugen
        System.out.println("\t... 1. Thread erzeugt ...");
        b2.start(); // 2. Thread zeugen
        System.out.println("\t... 2. Thread erzeugt ...");
        System.out.println("\t... und fertig ...");
    }   // <- Haupt-Thread beenden
}

1. Programm nicht beendet, nach Verlassen der main-Routine
2. Programm erst beendet, wenn alle Threads beendet
3. Threads werden gleichzeitig abgearbeitet
4. Ablauf der Threads zueinander nicht vorhersehbar
5. Threads teilen sich gleiche Variablen

package vl_java;

public class VL_10_Beispiel58_1 extends Thread {
    static int m_iCnt = 0;  // *

    public void run() {
        for (int i = 0; i < 100; ++i) {
            if (m_iCnt % 2 == 0)
                System.out.print("\t");
            System.out.println(++m_iCnt);   // * beide Threads: Zugriff auf gleiche Klassenvariable
        }
    }
    // run()-Methode nicht atomar: Threads verschränken sich ineinander => Vorsicht mit print-Anweisungen in mehreren Threads
    public static void main(String[] args) throws Exception {
        VL_10_Beispiel58_1 b1 = new VL_10_Beispiel58_1();
        VL_10_Beispiel58_1 b2 = new VL_10_Beispiel58_1();
        b1.start();
        b2.start();
    }
}

Nochmal: Threads teilen sich die gleichen Variablen, aber ...
- ... eine Methode muss die Variable nicht immer neu auslesen

package vl_java;

public class VL_10_Beispiel58_1_1 extends Thread {
    int i = 0;

    public void run() {
        while (i == 0) ;  // läuft solange, bis i sich ändert
    }

    public static void main(String[] args) throws Exception {
        VL_10_Beispiel58_1_1 b = new VL_10_Beispiel58_1_1();
        b.start();
        System.out.println("run läuft noch");
        Thread.sleep(2000);
        System.out.println("jetzt sollte gleich Schluss sein");
        b.i = 10;   // hier ändert sich i, folglich sollte der Thread sich beenden, aber ...
    }
}

- Schlüsselwort: volatile
    -> sagt Compiler, eine Variable darf in einem anderen Thread geändert werden
    -> Folge: Variable wird in Methode nicht zwischengespeichert, sondern Wert wird immer aus Speicher ausgelesen
    -> Änderungen weitergegeben, so:

package vl_java;

public class VL_10_Beispiel58_1_2 extends Thread {
    volatile int i = 0;

    public void run() {
        while (i == 0) ;  // jetzt wird i immer neu ausgelesen
    }

    public static void main(String[] args) throws Exception {
        VL_10_Beispiel58_1_2 b = new VL_10_Beispiel58_1_2();
        b.start();
        System.out.println("run läuft noch");
        Thread.sleep(2000);
        System.out.println("jetzt sollte gleich Schluss sein");
        b.i = 10;   // diese Änderung bemerkt run jetzt
    }
}
________________________________________________________________________________________________________________________
    Vorlesung 11 - Beenden von Threads

- Programm ist beendet: Wenn alle Threads (inklusive des Hauptthreads) beendet sind
- Ein einzelner Thread zu Ende => Wenn run()-Methode zu Ende
- Um von außen Thread beenden => dem Thread Nachricht zuschicken,
  worauf der Thread in run()-Methode reagiert und sich selber dadurch beendet
  => Threads werden nicht beendet, sondern beenden sich selber

class Thread... {
    public void interrupted();
    public boolean isInterrupted();
    ...
}

- interrupt-Methode schickt Thread Nachricht, um sie zu beenden
- Nachricht setzt ein boolesches, internes Flag, beendet Thread aber nicht
- Flag kann mittels isInterrupted-Methode abgefragt werden
- run()-Methode muss Flag abfragen: nicht zu oft, nicht zu selten
- Frage: Warum nicht zu oft, warum nicht zu selten?

package vl_java;

public class VL_11_Beispiel58_2 extends Thread {
    String m_Msg;

    public VL_11_Beispiel58_2(String msg) {
        m_Msg = msg;
    }

    public void run() {
        while (!isInterrupted()) {  // Druckt die Nachricht so lange aus, bis Interrupt Signal kommt
            System.out.println(m_Msg);
        }
    }
    public static void main(String[] args) throws Exception{
        VL_11_Beispiel58_2 b1 = new VL_11_Beispiel58_2("Hello World");
        VL_11_Beispiel58_2 b2 = new VL_11_Beispiel58_2("cool... ");
        b1.start(); System.out.println("\t 1. Thread erzeugt... ");
        b2.start(); System.out.println("\t 2. Thread erzeugt... ");
        Thread.sleep(1000); // Unterbrich den 1. Thread nach 1 Sekunde
        b1.interrupt();
        System.out.println("\t... Schluss mit \"Hello World\" ...");
        Thread.sleep(100);  // Unterbricht den 2. Thread nach weiteren 0,1 Sekunde
        b2.interrupt();
        System.out.println("\t Nix mit \"cool\"...");
        System.out.println("\t Und Tschuess ...");
    }
}

- Probleme mit interrupt-Methode:
    -> sleep()-Methode fängt ebenfalls Interrupt-Signal ab
    -> Wird interrupt() während sleep() aufgerufen, wird ...
        1. sleep() unterbrochen
        2. InterruptedException Exception geworfen
        3. interne Interrupt-Flag zurückgesetzt
    -> run() wird nict beendet
        public void run(){
            while(!isInterrupted()){
                System.out.println(m_Msg);
                try{Thread.sleep((int)(Math.random() * 1500));
                } catch (InterruptedException e) {}
            }
        }

- Lösung:
    -> In Exception-Behandlung von sleep(), wieder interrupt() aufrufen:
        public void run(){
            while(!isInterrupted()){
                System.out.println(m_Msg);
                try{
                    Thread.sleep((int)(Math.random() * 1500));
                } catch (InterruptedException e){
                    interrupt();
                }
            }
        }

Ursprungsproblem
- Aufgabe: zwei Fenster öffnen, darin springen Bälle auf- und ab
- Lösung:
    -> 1. Klasse für beide Bälle von Thread ableiten
    -> 2. in run(), anime() aufrufen (oder Inhalt von anime() in run() kopieren)
    Problem: ???

- Das Runnable-Interface:
  -> Problem: In Java: Man kann eine Klasse von maximal einer anderen Klasse ableiten
     Sprich: Klasse A kann nicht gleichzeitig von JFrame und Thread ableiten

  -> Lösung: Eigenen Klasse Runnable-Interface implementieren.
     Einen neuen Thread übergibt man dann ein Objekt dieser neuen Klasse

     class Thread ... {
        public Thread(Runnable obj);
        ..
     }

- Runnable-Interface - Allgemeines Schema:
  interface Runnable{
    public void run();
  }

  class Juhu extensd JFrame implements Runnable{
    ...
    public void run() { ... }   // Diese Methode soll nebenläufig ausgeführt werden
    ...
  }
  ...
  Juhu j = new Juhu();  // legt ein neues Juhu Objekt an
  Thread t = new Thread(j); // legt einen neuen Thread für das Juhu Objekt an
  t.start();    // startet Juhu run() und arbeitet parallel weiter
  ...

package vl_java;


public class VL_11_Beispiel58_5 implements Runnable {
    String m_Msg;

    public VL_11_Beispiel58_5(String msg) {
        m_Msg = msg;
    }

    public void run() {
        while (true) {    // Thread kann nicht beendet werden
            System.out.println(m_Msg);
            try {
                Thread.sleep((int) (Math.random() * 1500));
            } catch (InterruptedException e) {
            }
        }
    }

    public static void main(String[] args) throws Exception {
        VL_11_Beispiel58_5 b1 = new VL_11_Beispiel58_5("Hello World");
        VL_11_Beispiel58_5 b2 = new VL_11_Beispiel58_5("cool...");
        Thread t1 = new Thread(b1); // *
        Thread t2 = new Thread(b2); // * 2 neue Threads erzeugen
        t1.start(); // *
        System.out.println("\t... 1. Thread erzeugt ...");
        t2.start(); // * beide Threads starten
        System.out.println("\t... 2. Thread erzeugt ...");
        System.out.println("\t Und Tschuess...");
    }
}

- Problem: Wie run() der eigenen Klasse beenden? Runnable-Inteface hat kein interrupt- oder isInterrupted()
- Lösung: Selber implementieren

package vl_java;

public class VL_11_Beispiel58_6 implements Runnable {
    String m_Msg;
    volatile boolean m_bCont = true;    // neu

    public VL_11_Beispiel58_6(String msg) {
        m_Msg = msg;
    }

    public void nuAberSchluss() {   // neu
        m_bCont = false;
    }

    public void run() {
        while (m_bCont) {
            System.out.println(m_Msg);
            try {
                Thread.sleep((int) (Math.random() * 150));
            } catch (InterruptedException e) {} // Hier keine muss für Exception Behandlung
        }
    }
    public static void main(String[] args) throws Exception{
        VL_11_Beispiel58_6 b1 = new VL_11_Beispiel58_6("Hello World");
        VL_11_Beispiel58_6 b2 = new VL_11_Beispiel58_6("cool...");
        Thread t1 = new Thread(b1); Thread t2 = new Thread(b2);
        t1.start(); System.out.println("\t... 1. Thread erzeugen ...");
        t2.start(); System.out.println("\t... 2. Thread erzeugen ...");
        Thread.sleep(2000); b1.nuAberSchluss(); // *
        Thread.sleep(1000); b2.nuAberSchluss(); // * Sendet den Objekten, nicht den Threads, den Beenden-Wunsch
        System.out.println("\t... Und Tschuess ...");
    }
}

- Anhalten von Threads
    -> Manchmal möchte man, dass einzelne Threads Berechnungen unterbrechen und anhalten/warten, bis bestimmte Berechnungen fertig sind
    -> Dieses Anhalten kann wie Interrupt nicht von außen erzwungen werden, sondern ...
    -> ... run() Methode muss selber entscheiden, ob sie warten möchte
    -> ähnlich wie Interrupt, kann dies mittels boolenschen Flag,  gelöst werden

package vl_java;

public class VL_11_Waiting1 implements Runnable {
    private String m_Msg;
    private volatile boolean m_bWaiting = false;    // m_bWaiting wird außerhalb von run() gesetzt, aber innerhalb gelesen => volatile

    public VL_11_Waiting1(String msg) {
        m_Msg = msg;
    }

    public void run() {
        try {
            while (true) {
                while (m_bWaiting)
                    ; // busy waiting: do nothing but check again   // während Warten, immer wieder nichts machen: SEHR TEUER, GANZ SCHLECHT
                System.out.println(m_Msg);
                Thread.sleep((int) (Math.random() * 800));
            }
        } catch (InterruptedException e) {
        }
    }

    public void stopThisThing() {
        m_bWaiting = true;  // *
    }

    public void restart() {
        m_bWaiting = false; // * setzen des Flags
    }

    public static void main(String[] args) throws Exception {
        VL_11_Waiting1 b1 = new VL_11_Waiting1("Hello World");
        VL_11_Waiting1 b2 = new VL_11_Waiting1("cool...");
        new Thread(b1).start(); // Starten der beiden Threads
        System.out.println("\t... 1. Thread erzeugt...");
        new Thread(b2).start();
        System.out.println("\t... 2. Thread erzeugt...");
        System.out.println("\t... und fertig ...");
        Thread.sleep(5000); // nach 5 Sekunden ...
        System.out.println("\t... stop 1. Thread...");
        b1.stopThisThing(); // ... pausieren des 1. Threads
        Thread.sleep(5000);
        System.out.println("\t testart 1. Thread ...");
        b1.restart();   // ... reaktivieren des 1. Threads
    }
}

- Warten kostet viel Rechenzeit, in der nichts passiert
- Das ständige Testen des Flags ist schlecht
- Besser: Zwischen Flag-Abfragen ein wenig zu schlagen

public class Waiting2 implements Runnable{
    ...
    public void run(){
        try{
            while(true){
                while(m_bWaiting)
                    Thread.sleep(20); // NO busy waiting: sleep a little bit
                System.out.println(m_Msg);
                Thread.sleep((int)(Math.random() * 800));
            }
        } catch(InterrupedException e) {}
    }
    ...
}

- Diese Lösung ist besser, aber noch nicht gut
- Soll ein Thread warten, besser wait() aufzurufen
- Dadurch: Es wird aus Thread Scheduler entfernt => kostet keine Rechenzeit mehr
- Um Thread von außen wiederzustarten: notify() aufrufen
- Beide Methoden, mit Thread synchronisieren
- Diese Problematik ausführlich behandelt => in Parallelprogrammierung

package vl_java;

public class VL_11_Waiting3 implements Runnable{
    private String m_Msg;
    private volatile boolean m_bWaiting = false;    // m_bWaiting wird außerhalb von run() gesetzt, aber innerhalb gelesen => volatile

    public VL_11_Waiting3(String msg) {
        m_Msg = msg;
    }
    public void run(){
        try{
            while(true){
                if(m_bWaiting){
                    synchronized(this) {  // wait() muss synchronisiert werden
                        wait(); // sleep until notify()
                        m_bWaiting = false; // nach dem Aufwachen, Flag löschen
                    }
                }
                System.out.println(m_Msg);
                Thread.sleep((int)(Math.random() * 800));
            }
        } catch(InterruptedException e){}
    }
    public void stopThisThing(){
        m_bWaiting = true;  // wie gehabt
    }
    synchronized public void restart(){
        notify();   // auch notify() muss synchronisiert werden
    }
}

Ursprungsproblem: parallele Animation
- Aufgabe: öffne zwei Fenster, darin sollen Bälle auf- und abspringen
- Lösung:
    1. Klasse mit beiden Bällen muss Runnable-Interface implementieren
    2. in run(), anime() aufrufen (oder Inhalt von anime() in run() kopieren)
    3. Im Hauptprogramm: zwei Threads anlegen und starten

package vl_java;

import javax.swing.*;
import java.awt.*;

public class VL_11_Beispiel59 extends JFrame implements Runnable {
    public VL_11_Beispiel59(int iSleeper) throws Exception {
    }

    public void paintComponent(Graphics g) {
    }

    public void anime() throws Exception {
    }

    public void run() {
        try {
            anime();
        } catch (Exception e) {
        }
    }

    public static void main(String[] args) throws Exception {
        VL_11_Beispiel59 b1 = new VL_11_Beispiel59(20);
        VL_11_Beispiel59 b2 = new VL_11_Beispiel59(13);
        Thread t1 = new Thread(b1);
        Thread t2 = new Thread(b2);
        t1.start();
        t2.start();
    }
}

Mehrfache Animation in einem Fenster
- Aufgabe: ein Fenster -> mehrere Bälle auf- und ab -> jew. untersch. Geschw.
- Idee: Für jeden Ball, eigenen Thread
- Problem: Wie soll Fenster mit einzelnen Threads kommunizieren (in paintComponent() notwendig) ?
- Lösung:
    -> Eigene Dialogkomponente, beinhaltet als Hauptbestandteil, die Animation
    -> Eine eigene Klasse entwickeln, die
        - implementiert Runnable-Interface
        - startet am Anfang Thread, um eigene Animation zum Laufen zu bringen

- Fragen: Muss Klasse von irgendeiner Klasse abgeleitet sein?
- Welche methoden implementieren?
- Antwort:
    -> Klasse von JComponent ableiten
    -> Methode vom JComponent-Klasse
        public Dimension getMinimumSize()
        public Dimension getPreferredSize()
        müssen überschrieben werden
    -> In Klasse, Runnable-Interface implementieren
    -> Dazu: eine public void run() implementieren (enthält eigentliche Animation)
    -> Klasse muss darauf reagieren: Größe wird von außen verändert

- Allgemeine Struktur:
class Bounce extends JComponent implements Runnable{
    Bounce(){
        ...
        Thread t = new Thread(this);    //startet für sich selber einen Thread
        t.start();
    }
    @Override
    public void paintComponent(Graphics g){ ... }  // zeichnet den Ball an der aktuellen Position
    public void run(){  // enthält die Animation
        while(true){ ... }
    }
    @Override
    public Dimension getPreferredSize(){ ... }
    @Override
    public Dimension gerMinimumSize() { ... }   // gibt die Größe der Komponente an
}

- Anwendung Bounce-Klasse: wird verwendet, wie jedes normale Dialogelement

package vl_java;

import javax.swing.*;
import java.awt.*;
import java.awt.event.*;

public class VL_11_Bounce_1 extends JComponent implements Runnable {
    Image m_Img;
    volatile int m_iHeight = 0;
    volatile int m_iMaxHeight = 0;
    int m_iWait = 25;
    volatile int m_iImpress = 0;

    VL_11_Bounce_1() throws Exception {
        m_Img = getToolkit().createImage("src/vl_java/ZZ5H.gif");
        MediaTracker mt = new MediaTracker(this);
        mt.addImage(m_Img, 0);
        mt.waitForAll();
        Thread t = new Thread(this);
        t.start();
        addComponentListener(new ComponentAdapter() {
            public void componentResized(ComponentEvent e) {
                m_iMaxHeight = getHeight() - m_Img.getHeight(VL_11_Bounce_1.this);
            }
        });
    }

    public void run() {
        try {
            while (true) {
                for (m_iHeight = m_iMaxHeight; m_iHeight > 0; m_iHeight -= 5) {
                    Thread.sleep(m_iWait);
                    repaint();
                }
                m_iHeight = 0;
                impress(false);
                for (m_iHeight = 0; m_iHeight < m_iMaxHeight; m_iHeight += 5) {
                    Thread.sleep(m_iWait);
                    repaint();
                }
                m_iHeight = m_iMaxHeight;
                impress(true);
            }
        } catch (InterruptedException e) {
        }
    }


    @Override
    public Dimension getPreferredSize() {
        return getMinimumSize();
    }

    @Override
    public Dimension getMinimumSize() {
        return new Dimension(m_Img.getWidth(this), m_Img.getHeight(this) * 3);
    }

    @Override
    public void paintComponent(Graphics g) {
        if(m_iMaxHeight == 0)
            m_iMaxHeight = getHeight() - m_Img.getHeight(this);
        g.drawImage(m_Img, 0, m_iHeight, m_Img.getWidth(this), m_Img.getHeight(this) - m_iImpress, this);
    }
    private void impress(boolean bAtBottom) throws InterruptedException{
        for(m_iImpress = 0; m_iImpress < 20; ++m_iImpress){
            if(bAtBottom)
                ++m_iHeight;
            Thread.sleep(m_iWait);
            repaint();
        }
        for(m_iImpress = 20; m_iImpress > 0; --m_iImpress){
            if(bAtBottom)
                --m_iHeight;
            Thread.sleep(m_iWait);
            repaint();
        }
    }
}

- Aufgabe (Wiederholung)
    -> ein Fenster, mehrere Bälle, auf- und ab, unterschied. Geschw.
    -> mehr Bälle kein Problem: Bounce-Klasse muss mehrfach instanziert werden
    -> unterschiedliche Geschw. auch kein Problem. Jedes Bounce-Objekt arbeitet unterschiedlich schnell (m_iWait Variable)

package vl_java;
import javax.swing.*;
import java.awt.*;
public class VL_11_Beispiel60_2 {
    public static void main(String[] args) throws Exception {
        JFrame f = new JFrame();
        f.setLayout(new GridLayout(1, 2));
        VL_11_Bounce_1 b1 = new VL_11_Bounce_1();
        VL_11_Bounce_1 b2 = new VL_11_Bounce_1();
        f.add(b1); f.add(b2); f.pack(); f.setVisible(true);
        Thread.sleep(5000);
        System.out.println("nu aber los ...");
        b1.setWait(10);
    }
}

- Aufgabe: Zu jedem Ball JScrollBar implementieren, um Geschwindigkeit einstellen
- Lösung:
    -> Bounce-Objekt und JScrollBar in ein JPanel vereinen
    -> JScrollBar-Event abfangen, durch setWait() des Bounce-Objekts, Geschwindigkeit einstellen
    -> Für mehrfache Kombination, alles in eine Klasse zusammenfassen
    -> Von welcher Klasse, die Klasse ableiten, um es als Dialog-Element zu verwenden?

package vl_java;
import javax.swing.*;
import java.awt.*;
public class VL_11_Beispiel61 {
    public static void main(String[] args) throws Exception{
        JFrame f = new JFrame();
        f.setLayout(new GridLayout(1, 3));
        f.add(new VL_11_ControlBounce());
        f.add(new VL_11_ControlBounce());
        f.add(new VL_11_ControlBounce());
        f.pack();
        f.setVisible(true);
    }
}
________________________________________________________________________________________________________________________
    Vorlesung 12 - Komplexe Dialogelemente in Swing
- folgende komplexe Dialogelemente in Swing:
    Swing        -       AWT
    __________________________
 -> JScrollPane  -  ScrollPane      // JScrollPane ähnlich wie ScrollPane, mit mehr Möglichkeiten der Einstellung
 -> JSplitPane
 -> JTabbedPane
 -> JTable
 -> JTree

Die JSplitPane Klasse
- JSplitPane teilt eine Komponente in 2 Teile, die entweder neben- oder untereinader dargestellt werden
- In den beide Teilen werden 2 Komponenten dargestellt
- Beide Teile werden durch einen sichtbaren Separator geteilt, kann vom Anwender zur Laufzeit verschoben werden
class JSplitPane{
    public JSplitPane(int orient);
    final int HORIZONTAL_SPLIT;
    final int VERTICAL_SPLIT;
    ...
}

- Beide darzustellenden Komponenten können dem Konstruktor dierekt übergeben werden
    public JSplitPane(int orient, Component left, Component right);
- oder nachträglich gesetzt werden
    public void setLeftComponent(Component comp); bzw.
    public void setTopComponent(Component comp);
- und
    public void setRightComponent(Component comp); bzw.
    public void setButtomComponent(Component comp);

- Update von beiden Komponenten kann während Verschiebung des Separators erfolgen, oder danach
    public JSplitPane(int orient, boolean continuousLayout, Component left, Component right);
- oder nachträglich gesetzt werden durch
    public void setContinupusLayout(boolean cont);
- Aktuell eingestellter Wert kann abgefragt werden, mittels
    public boolean isContinuousLayout();

- Separator kann mit Pfeilen versehen werden, die jeweils Teil der JPlitPane komplett verdecken,
  wenn entsprechender Pfeil angeklickt wird

- Methode
    public void setOneTouchExpandable(boolean cont);
  setzt diese Pfeile

- Aktuell eingestellter Wert kann abgefragt werden, mittels
    public boolean isOneTouchExpandable();

package vl_java;
import javax.swing.*;
import java.awt.*;
public class VL_12_Beispiel72 extends JFrame{
    public VL_12_Beispiel72(){
        final JSplitPane pane = new JSplitPane(JSplitPane.HORIZONTAL_SPLIT, true, new VL_12_Grid(10, 20), new VL_12_Grid(3, 7));    // erzeugt eine JSplitPane und 2 Grid's unterschiedlicher Größe
        JPanel cntlPane = new JPanel();
        cntlPane.setLayout(new FlowLayout());
        JButton orient = new JButton("Orientation");    // *
        JButton cont = new JButton("Continuous");       // *
        JButton expand = new JButton("1 Touch Expand"); // * 3 JButtons zur Einstellung von Eigenschaften der JSplitPane
        cntlPane.add(orient);
        cntlPane.add(cont);
        cntlPane.add(expand);
        setLayout(new BorderLayout());
        add(BorderLayout.CENTER, pane);
        add(BorderLayout.NORTH, cntlPane);

        orient.addActionListener(e -> {
            if(pane.getOrientation() == JSplitPane.HORIZONTAL_SPLIT)    // *
                pane.setOrientation(JSplitPane.VERTICAL_SPLIT); //*
            else
                pane.setOrientation(JSplitPane.HORIZONTAL_SPLIT);   // * setzt die Orientierung um
        });
        cont.addActionListener(e -> pane.setContinuousLayout(!pane.isContinuousLayout()));  // toggelt den Update-Modus
        expand.addActionListener(e -> pane.setOneTouchExpandable(!pane.isOneTouchExpandable()));    // schaltet Pfeile ein- und aus
        pack();
        setVisible(true);
    }
    public static void main(String[] args){
        new VL_12_Beispiel72();
    }
}

Die JTabbedPane Klasse
- Verwaltet mehrere Registrierungskarten
- Es wird immer eine Karte angezeigt
- Jede Karte kann wieder eine Komponente erhalten
- Jede Karte hat einen Namen
- Namen werden den Karten an einem Rand zugeordnet
- Durch Namenauswahl wird die assoziierte Karte in den Vordergrund gebracht

class JTabbedPane{
    public JTabbedPane();
    public JTabbedPane(int orient); // Standard ist TOP
    final int TOP;
    final int BOTTOM;
    final int LEFT;
    final int RIGHT;
    ...
}

- Konstruktoren erzeugen noch keine Karten
- Karten werden mittels addTab() und insertTab() hinzugefügt
    addTab(): nacheinander
    insertTab(): an angegebener Position, startend bei 0

class JTabbedPane{
    public void addTab(String title, Component component);
    public void addTab(String title, Icon icon, Component component);
    public void addTab(String title, Icon icon, Component component, String tip);
    public void insertTab(String title, Icon icon, Component component, String tip, int index);
    ...
}

- Position, an denen Namen zu den Karten stehen, können angefragt und gesetzt werden
class JTabbedPane{
    public void setTabPlacement(int orientation);
    public int getTabPlacement();
    ...
}

- Einzelne Karten können deaktiviert werden, können dann nicht mehr ausgewählt werden
  (Zählen fängt bei 0 an.)

  class JTabbedPane{
    public void setEnabledAt(int index, boolean enabled);
    public boolean isEnabledAt(int index);
    ...
  }

package vl_java;

import javax.swing.*;
import java.awt.*;
import java.awt.event.*;
import javax.swing.*;

class OrientButton extends JButton { // 2 eigene JButton Klassen
    public OrientButton(String title, final JTabbedPane PANE, final int ORIENT) {
        super(title);
        addActionListener(e -> PANE.setTabPlacement(ORIENT));   // Setzt die Ausrichtung der Kartennamen gemäß ORIENT
    }
}

class Enable extends JButton {
    public Enable(String title, final JTabbedPane PANE, final int INDEX) {
        super(title);
        addActionListener(e -> PANE.setEnabledAt(INDEX, !PANE.isEnabledAt(INDEX)));  // Toggelt das Enable-Flag für den Eintrag an der Position "INDEX"
    }
}

class Control extends JPanel{
    public Control(JTabbedPane pane){
        setLayout(new FlowLayout());
        add(new OrientButton("top", pane, JTabbedPane.TOP));
        add(new OrientButton("bottom", pane, JTabbedPane.BOTTOM));
        add(new OrientButton("left",  pane, JTabbedPane.LEFT));
        add(new Enable("enable\"Control Bounce\"", pane, 0));
        add(new Enable("enable\"Bounce\"", pane, 1));
    }
}

public class VL_12_Beispiel73 extends JFrame {
    public VL_12_Beispiel73() throws Exception{
        JTabbedPane pane = new JTabbedPane();
        pane.addTab("Control Bouncing", new VL_11_ControlBounce());
        pane.addTab("Bouncing", new VL_11_Bounce_1());
        pane.addTab("Control", null, new Control(pane), "Ich kontrolliere alles");
        add(pane);
        pack();
        setVisible(true);
    }
    public static void main(String[] args) throws Exception{
        new VL_12_Beispiel73();
    }
}

Die JTable Klasse
- Zur Darstellung von Tabellen als Dialogelemente
- Dieses komplexes Element hat eine Vielzahl von Einstellungsmöglichkeiten

class JTable{
    public JTable(Object[][] rowData, Object[] columnNames);
    ...
}

- In der einfachsten Form: Man übergibt der Tabelle die Daten in Form eines 2D-Arrays
- Beschriftung der Spalten ist ein 1D-Array
- Ein Objekt der JTable Klasse => eingebettet in ein JScrollPane, um größere Tabellen scrollen zu können
- Spaltenbeschriftung wird aktiviert, wenn Tabelle in ein JScrollPane eingebettet ist
- Viele Einstellungen erlauben unterschiedliche Selektionsmöglichkeiten

class JTable{
    public void setRowSelectionAllowed(boolean flag);
    public void setColumnSelectionAllowed(boolean flag);
    public void setSelectionMode(int selectionMode);
    public void setCellSelectionEnabled(boolean flag);
    ...
}

- Auch die Zellen-Größe kann eingestellt werden

class JTable{
    public void setRowHeight(int newHeight);
    public void setRowMargin(int newMargin);
    public void setIntercellSpacing(Dimension newSpacing);
    ...
}

- Sollen zwischen zellen (Standard) Linien gezogen weredn, oder nicht

class JTable{
    public void setShowGrid(boolean b);
    public void setShowHorizontalLines(boolean b);
    public void setShowVerticalLines(boolean b);
    ...
}

- Methode setAutoResizeMode() regelt, wie Breite der Spalten verändet werden soll,
  wenn Benutzer eine Spalte in ihrer Breite verändert

class JTable{
    public void setAutoResizeMode(int mode);
    final in AUTO_RESIZE_OFF;
    final int AUTO_RESIZE_LAST_COLUMN;
    final int AUTO_RESIZE_NEXT_COLUMN;
    final int AUTO_RESIZE_SUBSEQUENT_COLUMNS;
    final int AUTO_RESIZE_ALL_COLUMN;
    ...
}

- Zugriff auf einzelne Elemente erfolgt mittels Methode

class JTable{
    public Object getValueAt(int row, int column);
    public void setValueAt(Oject val, int row, int column);
    ...
}

- getValueAt liefert Objekt von Zeile row und Spalte column
- setValueAt speichert übergebenes Objekt val an gegebener Position

package vl_java;

import javax.swing.*;

public class VL_12_Beispiel74 extends JFrame {
    public VL_12_Beispiel74() {
        Object[][] data = new Object[200][3];   // Erzeugung von Daten und Spaltenbeschriftungen
        String[] names = new String[data[0].length];
        for (int i = 0; i < data.length; ++i) {
            for (int j = 0; j < data[i].length; ++j) {
                data[i][j] = "Datum :" + i + "x" + j;
            }
        }
        for (int i = 0; i < names.length; ++i)
            names[i] = "Spalte " + i;
        JTable tab = new JTable(data, names);   // Tabelle wird erzeugt
        tab.setSelectionMode(ListSelectionModel.MULTIPLE_INTERVAL_SELECTION);
        tab.setColumnSelectionAllowed(true);
        tab.setAutoResizeMode(JTable.AUTO_RESIZE_OFF);
        add(new JScrollPane(tab));  // JTable wird fast immer mit JScrollPane verwendet
        pack();
        setVisible(true);
    }

    public static void main(String[] args){
        new VL_12_Beispiel74();
    }
}

- Nicht immer sinnvoll, der Tabelle bei Initialisierung alle Daten mitzugeben
- Tabelle kann anstelle der Daten, ein Objket übergeben werden, dass dir Daten bereitstellt, falls nötig
- Solche Klasse muss das TableModel Interface implementieren

class JTable{
    public JTable(TableModel tm);
    public void setModel(TableModel tm);
    public TableModel getModel();
    ...
}

- TableModel Interface stellt eine Reihe von Methoden zur Verfügung, um Tabelle Infos über Daten
  zur Verfügung zu stellen

interface TableModel{
    public int getRowCount();
    public int getColumnCount();
    public String getColumnName(int columnIndex);
    public Class getColumnClass(int columnIndex);
    public boolean isCellEditable(int rowIndex, int columnIndex);
    public Object getValueAt(int rowIndex, int columnIndex);
    public void setValueAt(Object val, int rowIndex, int columnIndex);
    public void addTableModelListener(TableModelListener l);
    public void removeTableModelListener(TableModelListener l);
}

- Um nicht alle Methoden von TableModel implementieren zu müssen:
  abstrakte Klasse AbstractTableModel stellt eine Teilimplementierung des TableModel Interface da
- Weiterhin: Klasse stellt Methoden zur Verfügung, um TableModelListener zu benachrichtigen:
  eine oder mehrere Zellen haben sich verändert

abstract class AbstractTableModel{
    ...
    void fireTableCellUpdated(int row, int column);
    void fireTableDataChanged();
    ...
}

package vl_java;

import javax.swing.*;
import javax.swing.table.AbstractTableModel;
import java.awt.event.*;
import java.awt.*;

class IntTab extends AbstractTableModel {
    int[][] m_Data; // Implementiert eine Integer Tabelle
    int m_iResult = 0; // m_iResult enthält die Summe aller Werte

    public IntTab(int x, int y) {
        m_Data = new int[x][y];
    }

    public int getRowCount() {
        return m_Data.length;
    }

    public int getColumnCount() {
        return m_Data[0].length;
    }

    public String getColumnName(int i) {
        return "Spalte " + i;
    }

    public boolean isCellEditable(int x, int y) {
        return true;
    }

    public Object getValueAt(int x, int y) { // liefert den Wert an Position (x, y) als String zurück
        return m_Data[x][y];
    }

    public void setValueAt(Object val, int rowIndex, int columnIndex){
        try{
            int iNewValue = Integer.parseInt((String)val);  // versucht, val in Interger zu konvertieren
            m_iResult -= m_Data[rowIndex][columnIndex];
            m_iResult += iNewValue;
            m_Data[rowIndex][columnIndex] = iNewValue;
            fireTableCellUpdated(rowIndex, columnIndex);    // benachrichtigt Listener
        } catch (Exception e) {}
    }
}

class TabWithResult extends JPanel{
    public TabWithResult(int rows, int columns){
        final JLabel RES_LAB = new JLabel("Summe: 0");
        final IntTab TAB_MOD = new IntTab(rows, columns);
        setLayout(new BorderLayout());
        add(BorderLayout.NORTH, RES_LAB);
        add(BorderLayout.CENTER, new JScrollPane(new JTable(TAB_MOD)));
        TAB_MOD.addTableModelListener(e -> RES_LAB.setText("Summe: " + TAB_MOD.m_iResult)); // Sobald sich etwas in dem Tabellen Modell geändert hat, wird das Laben neu dargestellt
    }
}

public class VL_12_Beispiel75 extends JFrame {
    public VL_12_Beispiel75() {
        JTabbedPane pane = new JTabbedPane();
        pane.add(new TabWithResult(10, 3), "klein");
        pane.add(new TabWithResult(250, 10), "groß");
        add(pane);
        pack();
        setVisible(true);
    }

    public static void main(String[] args) throws Exception {
        new VL_12_Beispiel75();
    }
}

Die JTree Klasse
- Zur Darstellung von baumartigen Strukturen
- Werden im Explorer verwendet
- Wird unterschieden: Ob Wurzel sichtbar oder unsichtbar sind => d.h. Kinder werden sofort dargestellt

class JTree{
    public JTree(TreeNode root);
    public void setRootVisible(boolean b);
    public boolean isRootVisible();
    ...
}

- Einfachste Form: Man übergibt Baum bei Erzeugung, den Wurzelknoten
- Dazu: Knoten muss Interface TreeNode implementieren
- TreeNode Interface: erwartet Reihe von Methoden, erforderlich für Aufbau von Baumstruktur
- Name im Baum erzeugt durch toString()

interface TreeNode{
    public Enumeration children();
    public boolean getAllowsChildren();
    public TreeNode getChildAt(int childIndex);
    public int getChildCount();
    public int getIndex(TreeNode node);
    public TreeNode getParent();
    public boolean isLeaf();
}

- Entsprechende Listener, um auf Auseinander-  und Zusammenfalten des Baums zu reagieren
- Unterschied zwischen Zeit vor- sowie nach Ausführung
  (TreeWillExpandListener bzw. TreeExpansionListener).
- Auf Selection von ein oder mehr Knoten wird durch TreeSelectionListener reagiert

class JTree{
    ...
    public void addTreeExpansionListener(TreeExpansionListener l);
    public void addTreeSelectionListener(TreeSelectionListener l);
    public void addTreeWillExpandListener(TreeWillExpandListener l);
}

package vl_java;

import java.awt.*;
import java.awt.event.*;
import java.util.*; // Nötig für Deklaration von Enumeration
import javax.swing.*;
import javax.swing.event.*; // für Listener
import javax.swing.tree.*;  // für TreeNode

class MyNode implements TreeNode {
    MyNode[] m_Kids = null; // *
    MyNode m_Father;    // *
    String m_Name;  // * Jeder Knoten merkt sich seine Kinder, seinen Vater und seinen Namen

    public MyNode() {
        this(null, 0);
    }

    public MyNode(MyNode father, int pos) {
        m_Father = father;
        if (m_Father == null)
            m_Name = "Chef";
        else
            m_Name = String.valueOf(pos) + ". Sohn des " + m_Father.toString();
        m_Kids = new MyNode[(int) (Math.random() * 15)]; // Jeder Knoten hat Platz, um bos 15 Kinder zu speichern
    }

    public TreeNode getChildAt(int childIndex) {    // Kinder werden erzeugt, wenn auf sie zugegriffen wird
        if (m_Kids[childIndex] == null)
            m_Kids[childIndex] = new MyNode(this, childIndex);
        return m_Kids[childIndex];
    }

    public int getChildCount() {
        return m_Kids.length;
    }

    public TreeNode getParent() {
        return m_Father;
    }

    public boolean isLeaf() {
        return m_Kids.length == 0;
    }

    public String toString() {
        return m_Name;
    }

    public int getIndex(TreeNode kid) {
        return -1;
    }

    public boolean getAllowsChildren() {
        return false;
    }

    public Enumeration children() {
        return null;
    }
}   // end of MyNode declaration

public class VL_12_Beispiel76 extends JFrame {
    public VL_12_Beispiel76() {
        JTree tree = new JTree(new MyNode());
        tree.addTreeExpansionListener(new TreeExpansionListener() {
            public void treeCollapsed(TreeExpansionEvent e) {
                System.out.println("Collapsed " + e.getPath());
            }

            public void treeExpanded(TreeExpansionEvent e) {
                System.out.println("Expanded " + e.getPath());
            }
        });
        tree.addTreeSelectionListener(e -> System.out.println("Selected " + e.getPath()));
        tree.addTreeWillExpandListener(new TreeWillExpandListener() {
            public void treeWillExpand(TreeExpansionEvent e) {
                System.out.println("will expand " + e.getPath());
            }

            public void treeWillCollapse(TreeExpansionEvent e) {
                System.out.println("will collapse " + e.getPath());
            }
        });
        add(new JScrollPane(tree)); // Verwendung von JTree in JScrollPane
        pack();
        setVisible(true);
    }

    public static void main(String[] args) throws Exception {
        new VL_12_Beispiel76();
    }
}








